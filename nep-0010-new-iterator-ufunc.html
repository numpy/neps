
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NEP 10 — Optimizing iterator/UFunc performance &#8212; NumPy Enhancement Proposals</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="_static/documentation_options.js?v=7f41d439"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'nep-0010-new-iterator-ufunc';</script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="NEP 13 — A mechanism for overriding Ufuncs" href="nep-0013-ufunc-overrides.html" />
    <link rel="prev" title="NEP 7 — A proposal for implementing some date/time types in NumPy" href="nep-0007-datetime-proposal.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
    <meta name="docbuild:last-update" content="Jan 17, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="content.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/numpylogo.svg" class="logo__image only-light" alt="NumPy Enhancement Proposals - Home"/>
    <img src="_static/numpylogo.svg" class="logo__image only-dark pst-js-only" alt="NumPy Enhancement Proposals - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="scope.html">The Scope of NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Current roadmap</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">Wish list</a></li>
</ul>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="meta.html">Meta-NEPs (NEPs about NEPs or active Processes)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0000.html">NEP 0 — Purpose and process</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0023-backwards-compatibility.html">NEP 23 — Backwards compatibility and deprecation policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0036-fair-play.html">NEP 36 — Fair play</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0045-c_style_guide.html">NEP 45 — C style guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0046-sponsorship-guidelines.html">NEP 46 — NumPy sponsorship guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0048-spending-project-funds.html">NEP 48 — Spending NumPy project funds</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-template.html">NEP X — Template and instructions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="provisional.html">Provisional NEPs (provisionally accepted; interface may change)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="accepted.html">Accepted NEPs (implementation in progress)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0041-improved-dtype-support.html">NEP 41 — First step towards a new datatype system</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0042-new-dtypes.html">NEP 42 — New and extensible DTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0044-restructuring-numpy-docs.html">NEP 44 — Restructuring the NumPy documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0051-scalar-representation.html">NEP 51 — Changing the representation of NumPy scalars</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="open.html">Open NEPs (under consideration)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0043-extensible-ufuncs.html">NEP 43 — Enhancing the extensibility of UFuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0053-c-abi-evolution.html">NEP 53 — Evolving the NumPy C-API for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0054-simd-cpp-highway.html">NEP 54 — SIMD infrastructure evolution: adopting Google Highway when moving to C++?</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="finished.html">Finished NEPs</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nep-0001-npy-format.html">NEP 1 — A simple file format for NumPy arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0005-generalized-ufuncs.html">NEP 5 — Generalized universal functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0007-datetime-proposal.html">NEP 7 — A proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">NEP 10 — Optimizing iterator/UFunc performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0013-ufunc-overrides.html">NEP 13 — A mechanism for overriding Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0014-dropping-python2.7-proposal.html">NEP 14 — Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0015-merge-multiarray-umath.html">NEP 15 — Merging multiarray and umath</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0018-array-function-protocol.html">NEP 18 — A dispatch mechanism for NumPy's high level array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0019-rng-policy.html">NEP 19 — Random number generator policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0020-gufunc-signature-enhancement.html">NEP 20 — Expansion of generalized universal function signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0022-ndarray-duck-typing-overview.html">NEP 22 — Duck typing for NumPy arrays – high level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0027-zero-rank-arrarys.html">NEP 27 — Zero rank arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0028-website-redesign.html">NEP 28 — numpy.org website redesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0029-deprecation_policy.html">NEP 29 — Recommend Python and NumPy version support as a community policy standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0032-remove-financial-functions.html">NEP 32 — Remove the financial functions from NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0034-infer-dtype-is-object.html">NEP 34 — Disallow inferring ``dtype=object`` from sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0035-array-creation-dispatch-with-array-function.html">NEP 35 — Array creation dispatching with __array_function__</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0038-SIMD-optimizations.html">NEP 38 — Using SIMD optimization instructions for performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0040-legacy-datatype-impl.html">NEP 40 — Legacy datatype implementation in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0049.html">NEP 49 — Data allocation strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0050-scalar-promotion.html">NEP 50 — Promotion rules for Python scalars</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0052-python-api-cleanup.html">NEP 52 — Python API cleanup for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0055-string_dtype.html">NEP 55 — Add a UTF-8 variable-width string DType to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0056-array-api-main-namespace.html">NEP 56 — Array API standard support in NumPy's main namespace</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="deferred.html">Deferred and Superseded NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0002-warnfix.html">NEP 2 — A proposal to build numpy without warning with a big set of warning flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0003-math_config_clean.html">NEP 3 — Cleaning the math configuration of numpy.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0004-datetime-proposal3.html">NEP 4 — A (third) proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0006-newbugtracker.html">NEP 6 — Replacing Trac with a different bug tracker</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0008-groupby_additions.html">NEP 8 — A proposal for adding groupby functionality to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0009-structured_array_extensions.html">NEP 9 — Structured array extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0011-deferred-ufunc-evaluation.html">NEP 11 — Deferred UFunc evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0012-missing-data.html">NEP 12 — Missing data functionality in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0021-advanced-indexing.html">NEP 21 — Simplified and explicit advanced indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0024-missing-data-2.html">NEP 24 — Missing data functionality - alternative 1 to NEP 12</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0025-missing-data-3.html">NEP 25 — NA support via special dtypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0026-missing-data-summary.html">NEP 26 — Summary of missing data NEPs and discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0030-duck-array-protocol.html">NEP 30 — Duck typing for NumPy arrays - implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0031-uarray.html">NEP 31 — Context-local and global overrides of the NumPy API</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0037-array-module.html">NEP 37 — A dispatch protocol for NumPy-like modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0047-array-api-standard.html">NEP 47 — Adopting the array API standard</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="rejected.html">Rejected and Withdrawn NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0016-abstract-array.html">NEP 16 — An abstract base class for identifying "duck arrays"</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0017-split-out-maskedarray.html">NEP 17 — Split out masked arrays</a></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="content.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Roadmap &amp; NumPy enhancement proposals</a></li>
    
    
    <li class="breadcrumb-item"><a href="finished.html" class="nav-link">Finished NEPs</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">NEP 10 — Optimizing iterator/UFunc performance</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="nep-10-optimizing-iterator-ufunc-performance">
<span id="nep10"></span><h1><a class="toc-backref" href="#id1" role="doc-backlink">NEP 10 — Optimizing iterator/UFunc performance</a><a class="headerlink" href="#nep-10-optimizing-iterator-ufunc-performance" title="Link to this heading">#</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mark Wiebe &lt;<a class="reference external" href="mailto:mwwiebe&#37;&#52;&#48;gmail&#46;com">mwwiebe<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Content-Type<span class="colon">:</span></dt>
<dd class="field-even"><p>text/x-rst</p>
</dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd"><p>25-Nov-2010</p>
</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><p>Final</p>
</dd>
</dl>
<section id="table-of-contents">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Table of contents</a><a class="headerlink" href="#table-of-contents" title="Link to this heading">#</a></h2>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#nep-10-optimizing-iterator-ufunc-performance" id="id1">NEP 10 — Optimizing iterator/UFunc performance</a></p>
<ul>
<li><p><a class="reference internal" href="#table-of-contents" id="id2">Table of contents</a></p></li>
<li><p><a class="reference internal" href="#abstract" id="id3">Abstract</a></p></li>
<li><p><a class="reference internal" href="#motivation" id="id4">Motivation</a></p>
<ul>
<li><p><a class="reference internal" href="#image-compositing-example" id="id5">Image compositing example</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#improving-cache-coherency" id="id6">Improving cache-coherency</a></p>
<ul>
<li><p><a class="reference internal" href="#output-layout-selection-algorithm" id="id7">Output layout selection algorithm</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#coalescing-dimensions" id="id8">Coalescing dimensions</a></p></li>
<li><p><a class="reference internal" href="#inner-loop-specialization" id="id9">Inner loop specialization</a></p></li>
<li><p><a class="reference internal" href="#implementation-details" id="id10">Implementation details</a></p>
<ul>
<li><p><a class="reference internal" href="#iterator-rewrite" id="id11">Iterator rewrite</a></p></li>
<li><p><a class="reference internal" href="#proposed-iterator-memory-layout" id="id12">Proposed iterator memory layout</a></p></li>
<li><p><a class="reference internal" href="#proposed-iterator-api" id="id13">Proposed iterator API</a></p>
<ul>
<li><p><a class="reference internal" href="#old-new-iterator-api-conversion" id="id14">Old -&gt; new iterator API conversion</a></p></li>
<li><p><a class="reference internal" href="#iterator-pointer-type" id="id15">Iterator pointer type</a></p></li>
<li><p><a class="reference internal" href="#construction-and-destruction" id="id16">Construction and destruction</a></p></li>
<li><p><a class="reference internal" href="#functions-for-iteration" id="id17">Functions for iteration</a></p></li>
<li><p><a class="reference internal" href="#examples" id="id18">Examples</a></p></li>
<li><p><a class="reference internal" href="#python-lambda-ufunc-example" id="id19">Python lambda UFunc example</a></p></li>
<li><p><a class="reference internal" href="#python-addition-example" id="id20">Python addition example</a></p></li>
<li><p><a class="reference internal" href="#image-compositing-example-revisited" id="id21">Image compositing example revisited</a></p></li>
<li><p><a class="reference internal" href="#image-compositing-with-numexpr" id="id22">Image compositing with NumExpr</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Abstract</a><a class="headerlink" href="#abstract" title="Link to this heading">#</a></h2>
<p>This NEP proposes to replace the NumPy iterator and multi-iterator
with a single new iterator, designed to be more flexible and allow for
more cache-friendly data access.  The new iterator also subsumes much
of the core ufunc functionality, making it easy to get the current
ufunc benefits in contexts which don’t precisely fit the ufunc mold.
Key benefits include:</p>
<ul class="simple">
<li><p>automatic reordering to find a cache-friendly access pattern</p></li>
<li><p>standard and customizable broadcasting</p></li>
<li><p>automatic type/byte-order/alignment conversions</p></li>
<li><p>optional buffering to minimize conversion memory usage</p></li>
<li><p>optional output arrays, with automatic allocation when unsupplied</p></li>
<li><p>automatic output or common type selection</p></li>
</ul>
<p>A large fraction of this iterator design has already been implemented with
promising results.  Construction overhead is slightly greater (a.flat:
0.5 us, nditer(a): 1.4 us and broadcast(a,b): 1.4 us, nditer([a,b]):
2.2 us), but, as shown in an example, it is already possible to improve
on the performance of the built-in NumPy mechanisms in pure Python code
together with the iterator.  One example rewrites np.add, getting a
four times improvement with some Fortran-contiguous arrays, and
another improves image compositing code from 1.4s to 180ms.</p>
<p>The implementation attempts to take into account
the design decisions made in the NumPy 2.0 refactor, to make its future
integration into libndarray relatively simple.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Motivation</a><a class="headerlink" href="#motivation" title="Link to this heading">#</a></h2>
<p>NumPy defaults to returning C-contiguous arrays from UFuncs.  This can
result in extremely poor memory access patterns when dealing with data
that is structured differently.  A simple timing example illustrates
this with a more than eight times performance hit from adding
Fortran-contiguous arrays together.  All timings are done using NumPy
2.0dev (Nov 22, 2010) on an Athlon 64 X2 4200+, with a 64-bit OS.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">28.5</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">d</span><span class="o">.</span><span class="n">T</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">237</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">d</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">29.6</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>In this case, it is simple to recover the performance by switching to
a view of the memory, adding, then reshaping back.  To further examine
the problem and see how it isn’t always as trivial to work around,
let’s consider simple code for working with image buffers in NumPy.</p>
<section id="image-compositing-example">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Image compositing example</a><a class="headerlink" href="#image-compositing-example" title="Link to this heading">#</a></h3>
<p>For a more realistic example, consider an image buffer.  Images are
generally stored in a Fortran-contiguous order, and the colour
channel can be treated as either a structured ‘RGB’ type or an extra
dimension of length three.  The resulting memory layout is neither C-
nor Fortran-contiguous, but is easy to work with directly in NumPy,
because of the flexibility of the ndarray.  This appears ideal, because
it makes the memory layout compatible with typical C or C++ image code,
while simultaneously giving natural access in Python. Getting the color
of pixel (x,y) is just ‘image[x,y]’.</p>
<p>The performance of this layout in NumPy turns out to be very poor.
Here is code which creates two black images, and does an ‘over’
compositing operation on them.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">al1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">al2</span><span class="p">):</span>
   <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="p">(</span><span class="n">im1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">al1</span><span class="p">)</span><span class="o">*</span><span class="n">im2</span><span class="p">,</span> <span class="n">al1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">al1</span><span class="p">)</span><span class="o">*</span><span class="n">al2</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">14</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">image2</span><span class="p">,</span><span class="n">alpha2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">3.51</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>If we give up the convenient layout, and use the C-contiguous default,
the performance is about seven times better.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">16</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">17</span><span class="p">]:</span> <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">18</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">19</span><span class="p">]:</span> <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">20</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">image2</span><span class="p">,</span><span class="n">alpha2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">581</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>But this is not all, since it turns out that broadcasting the alpha
channel is exacting a performance price as well.  If we use an alpha
channel with 3 values instead of one, we get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">21</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">23</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">24</span><span class="p">]:</span> <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">25</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">image2</span><span class="p">,</span><span class="n">alpha2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">313</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>For a final comparison, let’s see how it performs when we use
one-dimensional arrays to ensure just a single loop does the
calculation.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">26</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">27</span><span class="p">]:</span> <span class="n">alpha1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">28</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">29</span><span class="p">]:</span> <span class="n">alpha2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">30</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">alpha1</span><span class="p">,</span><span class="n">image2</span><span class="p">,</span><span class="n">alpha2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">312</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>To get a reference performance number, I implemented this simple operation
straightforwardly in C (careful to use the same compile options as NumPy).
If I emulated the memory allocation and layout of the Python code, the
performance was roughly 0.3 seconds, very much in line with NumPy’s
performance.  Combining the operations into one pass reduced the time
to roughly 0.15 seconds.</p>
<p>A slight variation of this example is to use a single memory block
with four channels (1920,1080,4) instead of separate image and alpha.
This is more typical in image processing applications, and here’s how
that looks with a C-contiguous layout.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">31</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">32</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">33</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
   <span class="o">....</span><span class="p">:</span>     <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">im1</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">im2</span>
   <span class="o">....</span><span class="p">:</span>     <span class="n">ret</span> <span class="o">+=</span> <span class="n">im1</span>
   <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="n">ret</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">34</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">image2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">481</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>To see the improvements that implementation of the new iterator as
proposed can produce, go to the example continued after the
proposed API, near the bottom of the document.</p>
</section>
</section>
<section id="improving-cache-coherency">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Improving cache-coherency</a><a class="headerlink" href="#improving-cache-coherency" title="Link to this heading">#</a></h2>
<p>In order to get the best performance from UFunc calls, the pattern of
memory reads should be as regular as possible. Modern CPUs attempt to
predict the memory read/write pattern and fill the cache ahead of time.
The most predictable pattern is for all the inputs and outputs to be
sequentially processed in the same order.</p>
<p>I propose that by default, the memory layout of the UFunc outputs be as
close to that of the inputs as possible.  Whenever there is an ambiguity
or a mismatch, it defaults to a C-contiguous layout.</p>
<p>To understand how to accomplish this, we first consider the strides of
all the inputs after the shapes have been normalized for broadcasting.
By determining whether a set of strides are compatible and/or ambiguous,
we can determine an output memory layout which maximizes coherency.</p>
<p>In broadcasting, the input shapes are first transformed to broadcast
shapes by prepending singular dimensions, then the broadcast strides
are created, where any singular dimension’s stride is set to zero.</p>
<p>Strides may be negative as well, and in certain cases this can be
normalized to fit the following discussion.  If all the strides for a
particular axis are negative or zero, the strides for that dimension
can be negated after adjusting the base data pointers appropriately.</p>
<p>Here’s an example of how three inputs with C-contiguous layouts result in
broadcast strides.  To simplify things, the examples use an itemsize of 1.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Input shapes:</p></td>
<td><p>(5,3,7)</p></td>
<td><p>(5,3,1)</p></td>
<td><p>(1,7)</p></td>
</tr>
<tr class="row-even"><td><p>Broadcast shapes:</p></td>
<td><p>(5,3,7)</p></td>
<td><p>(5,3,1)</p></td>
<td><p>(1,1,7)</p></td>
</tr>
<tr class="row-odd"><td><p>Broadcast strides:</p></td>
<td><p>(21,7,1)</p></td>
<td><p>(3,1,0)</p></td>
<td><p>(0,0,1)</p></td>
</tr>
</tbody>
</table>
</div>
<p><em>Compatible Strides</em> - A set of strides are compatible if there exists
a permutation of the axes such that the strides are decreasing for every
stride in the set, excluding entries that are zero.</p>
<p>The example above satisfies the definition with the identity permutation.
In the motivation image example, the strides are slightly different if
we separate the colour and alpha information or not.  The permutation
which demonstrates compatibility here is the transposition (0,1).</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Input/Broadcast shapes:</p></td>
<td><p>Image (1920, 1080, 3)</p></td>
<td><p>Alpha (1920, 1080, 1)</p></td>
</tr>
<tr class="row-even"><td><p>Broadcast strides (separate):</p></td>
<td><p>(3,5760,1)</p></td>
<td><p>(1,1920,0)</p></td>
</tr>
<tr class="row-odd"><td><p>Broadcast strides (together):</p></td>
<td><p>(4,7680,1)</p></td>
<td><p>(4,7680,0)</p></td>
</tr>
</tbody>
</table>
</div>
<p><em>Ambiguous Strides</em> - A set of compatible strides are ambiguous if
more than one permutation of the axes exists such that the strides are
decreasing for every stride in the set, excluding entries that are zero.</p>
<p>This typically occurs when every axis has a 0-stride somewhere in the
set of strides.  The simplest example is in two dimensions, as follows.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Broadcast shapes:</p></td>
<td><p>(1,3)</p></td>
<td><p>(5,1)</p></td>
</tr>
<tr class="row-even"><td><p>Broadcast strides:</p></td>
<td><p>(0,1)</p></td>
<td><p>(1,0)</p></td>
</tr>
</tbody>
</table>
</div>
<p>There may, however, be unambiguous compatible strides without a single
input forcing the entire layout, as in this example:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Broadcast shapes:</p></td>
<td><p>(1,3,4)</p></td>
<td><p>(5,3,1)</p></td>
</tr>
<tr class="row-even"><td><p>Broadcast strides:</p></td>
<td><p>(0,4,1)</p></td>
<td><p>(3,1,0)</p></td>
</tr>
</tbody>
</table>
</div>
<p>In the face of ambiguity, we have a choice to either completely throw away
the fact that the strides are compatible, or try to resolve the ambiguity
by adding an additional constraint.  I think the appropriate choice
is to resolve it by picking the memory layout closest to C-contiguous,
but still compatible with the input strides.</p>
<section id="output-layout-selection-algorithm">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Output layout selection algorithm</a><a class="headerlink" href="#output-layout-selection-algorithm" title="Link to this heading">#</a></h3>
<p>The output ndarray memory layout we would like to produce is as follows:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Consistent/Unambiguous strides:</p></td>
<td><p>The single consistent layout</p></td>
</tr>
<tr class="row-even"><td><p>Consistent/Ambiguous strides:</p></td>
<td><p>The consistent layout closest to C-contiguous</p></td>
</tr>
<tr class="row-odd"><td><p>Inconsistent strides:</p></td>
<td><p>C-contiguous</p></td>
</tr>
</tbody>
</table>
</div>
<p>Here is pseudo-code for an algorithm to compute the permutation for the
output layout.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">perm</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span> <span class="c1"># Identity, i.e. C-contiguous</span>
<span class="c1"># Insertion sort, ignoring 0-strides</span>
<span class="c1"># Note that the sort must be stable, and 0-strides may</span>
<span class="c1"># be reordered if necessary, but should be moved as little</span>
<span class="c1"># as possible.</span>
<span class="k">for</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="c1"># ipos is where perm[i0] will get inserted</span>
    <span class="n">ipos</span> <span class="o">=</span> <span class="n">i0</span>
    <span class="n">j0</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span><span class="o">-</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
        <span class="n">ambig</span><span class="p">,</span> <span class="n">shouldswap</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>
        <span class="c1"># Check whether any strides are ordered wrong</span>
        <span class="k">for</span> <span class="n">strides</span> <span class="ow">in</span> <span class="n">broadcast_strides</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">strides</span><span class="p">[</span><span class="n">j1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">strides</span><span class="p">[</span><span class="n">j1</span><span class="p">]:</span>
                    <span class="c1"># Only set swap if it&#39;s still ambiguous.</span>
                    <span class="k">if</span> <span class="n">ambig</span><span class="p">:</span>
                        <span class="n">shouldswap</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Set swap even if it&#39;s not ambiguous,</span>
                    <span class="c1"># because not swapping is the choice</span>
                    <span class="c1"># for conflicts as well.</span>
                    <span class="n">shouldswap</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">ambig</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># If there was an unambiguous comparison, either shift ipos</span>
        <span class="c1"># to i1 or stop looking for the comparison</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ambig</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shouldswap</span><span class="p">:</span>
                <span class="n">ipos</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="c1"># Insert perm[i0] into the right place</span>
    <span class="k">if</span> <span class="n">ipos</span> <span class="o">!=</span> <span class="n">i0</span><span class="p">:</span>
       <span class="k">for</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span><span class="o">-</span><span class="mi">1</span> <span class="n">to</span> <span class="n">ipos</span><span class="p">:</span>
         <span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
       <span class="n">perm</span><span class="p">[</span><span class="n">ipos</span><span class="p">]</span> <span class="o">=</span> <span class="n">j0</span>
<span class="c1"># perm is now the closest consistent ordering to C-contiguous</span>
<span class="k">return</span> <span class="n">perm</span>
</pre></div>
</div>
</section>
</section>
<section id="coalescing-dimensions">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Coalescing dimensions</a><a class="headerlink" href="#coalescing-dimensions" title="Link to this heading">#</a></h2>
<p>In many cases, the memory layout allows for the use of a one-dimensional
loop instead of tracking multiple coordinates within the iterator.
The existing code already exploits this when the data is C-contiguous,
but since we’re reordering the axes, we can apply this optimization
more generally.</p>
<p>Once the iteration strides have been sorted to be monotonically
decreasing, any dimensions which could be coalesced are side by side.
If for all the operands, incrementing by strides[i+1] shape[i+1] times
is the same as incrementing by strides[i], or strides[i+1]*shape[i+1] ==
strides[i], dimensions i and i+1 can be coalesced into a single dimension.</p>
<p>Here is pseudo-code for coalescing.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Figure out which pairs of dimensions can be coalesced</span>
<span class="n">can_coalesce</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">ndim</span>
<span class="k">for</span> <span class="n">strides</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">broadcast_strides</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">can_coalesce</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="c1"># Coalesce the types</span>
<span class="n">new_ndim</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">count_nonzero</span><span class="p">(</span><span class="n">can_coalesce</span><span class="p">)</span>
<span class="k">for</span> <span class="n">strides</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">broadcast_strides</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">):</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Note that can_coalesce[ndim-1] is always False, so</span>
        <span class="c1"># there is no out-of-bounds access here.</span>
        <span class="k">if</span> <span class="n">can_coalesce</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="inner-loop-specialization">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Inner loop specialization</a><a class="headerlink" href="#inner-loop-specialization" title="Link to this heading">#</a></h2>
<p>Specialization is handled purely by the inner loop function, so this
optimization is independent of the others.  Some specialization is
already done, like for the reduce operation.  The idea is mentioned in
<a class="reference external" href="http://projects.scipy.org/numpy/wiki/ProjectIdeas">http://projects.scipy.org/numpy/wiki/ProjectIdeas</a>, “use intrinsics
(SSE-instructions) to speed up low-level loops in NumPy.”</p>
<p>Here are some possibilities for two-argument functions,
covering the important cases of add/subtract/multiply/divide.</p>
<ul class="simple">
<li><p>The first or second argument is a single value (i.e. a 0 stride
value) and does not alias the output.  arr = arr + 1; arr = 1 + arr</p>
<ul>
<li><p>Can load the constant once instead of reloading it from memory every time</p></li>
</ul>
</li>
<li><p>The strides match the size of the data type. C- or
Fortran-contiguous data, for example</p>
<ul>
<li><p>Can do a simple loop without using strides</p></li>
</ul>
</li>
<li><p>The strides match the size of the data type, and they are
both 16-byte aligned (or differ from 16-byte aligned by the same offset)</p>
<ul>
<li><p>Can use SSE to process multiple values at once</p></li>
</ul>
</li>
<li><p>The first input and the output are the same single value
(i.e. a reduction operation).</p>
<ul>
<li><p>This is already specialized for many UFuncs in the existing code</p></li>
</ul>
</li>
</ul>
<p>The above cases are not generally mutually exclusive, for example a
constant argument may be combined with SSE when the strides match the
data type size, and reductions can be optimized with SSE as well.</p>
</section>
<section id="implementation-details">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Implementation details</a><a class="headerlink" href="#implementation-details" title="Link to this heading">#</a></h2>
<p>Except for inner loop specialization, the discussed
optimizations significantly affect ufunc_object.c and the
PyArrayIterObject/PyArrayMultiIterObject used to do the broadcasting.
In general, it should be possible to emulate the current behavior where it
is desired, but I believe the default should be to produce and manipulate
memory layouts which will give the best performance.</p>
<p>To support the new cache-friendly behavior, we introduce a new
option ‘K’ (for “keep”) for any <code class="docutils literal notranslate"><span class="pre">order=</span></code> parameter.</p>
<p>The proposed ‘order=’ flags become as follows:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>‘C’</p></td>
<td><p>C-contiguous layout</p></td>
</tr>
<tr class="row-even"><td><p>‘F’</p></td>
<td><p>Fortran-contiguous layout</p></td>
</tr>
<tr class="row-odd"><td><p>‘A’</p></td>
<td><p>‘F’ if the input(s) have a Fortran-contiguous layout, ‘C’ otherwise (“Any Contiguous”)</p></td>
</tr>
<tr class="row-even"><td><p>‘K’</p></td>
<td><p>a layout equivalent to ‘C’ followed by some permutation of the axes, as close to the layout of the input(s) as possible (“Keep Layout”)</p></td>
</tr>
</tbody>
</table>
</div>
<p>Or as an enum:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* For specifying array memory layout or iteration order */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Fortran order if inputs are all Fortran, C otherwise */</span>
<span class="w">        </span><span class="n">NPY_ANYORDER</span><span class="o">=</span><span class="mi">-1</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* C order */</span>
<span class="w">        </span><span class="n">NPY_CORDER</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* Fortran order */</span>
<span class="w">        </span><span class="n">NPY_FORTRANORDER</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* An order as close to the inputs as possible */</span>
<span class="w">        </span><span class="n">NPY_KEEPORDER</span><span class="o">=</span><span class="mi">2</span>
<span class="p">}</span><span class="w"> </span><span class="n">NPY_ORDER</span><span class="p">;</span>
</pre></div>
</div>
<p>Perhaps a good strategy is to first implement the capabilities discussed
here without changing the defaults.  Once they are implemented and
well-tested, the defaults can change from <code class="docutils literal notranslate"><span class="pre">order='C'</span></code> to <code class="docutils literal notranslate"><span class="pre">order='K'</span></code>
everywhere appropriate.  UFuncs additionally should gain an <code class="docutils literal notranslate"><span class="pre">order=</span></code>
parameter to control the layout of their output(s).</p>
<p>The iterator can do automatic casting, and I have created a sequence
of progressively more permissive casting rules.  Perhaps for 2.0, NumPy
could adopt this enum as its preferred way of dealing with casting.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* For specifying allowed casting in operations which support it */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Only allow identical types */</span>
<span class="w">        </span><span class="n">NPY_NO_CASTING</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* Allow identical and byte swapped types */</span>
<span class="w">        </span><span class="n">NPY_EQUIV_CASTING</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* Only allow safe casts */</span>
<span class="w">        </span><span class="n">NPY_SAFE_CASTING</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* Allow safe casts and casts within the same kind */</span>
<span class="w">        </span><span class="n">NPY_SAME_KIND_CASTING</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="w">        </span><span class="cm">/* Allow any casts */</span>
<span class="w">        </span><span class="n">NPY_UNSAFE_CASTING</span><span class="o">=</span><span class="mi">4</span>
<span class="p">}</span><span class="w"> </span><span class="n">NPY_CASTING</span><span class="p">;</span>
</pre></div>
</div>
<section id="iterator-rewrite">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Iterator rewrite</a><a class="headerlink" href="#iterator-rewrite" title="Link to this heading">#</a></h3>
<p>Based on an analysis of the code, it appears that refactoring the existing
iteration objects to implement these optimizations is prohibitively
difficult.  Additionally, some usage of the iterator requires modifying
internal values or flags, so code using the iterator would have to
change anyway.  Thus we propose creating a new iterator object which
subsumes the existing iterator functionality and expands it to account
for the optimizations.</p>
<p>High level goals for the replacement iterator include:</p>
<ul class="simple">
<li><p>Small memory usage and a low number of memory allocations.</p></li>
<li><p>Simple cases (like flat arrays) should have very little overhead.</p></li>
<li><p>Combine single and multiple iteration into one object.</p></li>
</ul>
<p>Capabilities that should be provided to user code:</p>
<ul class="simple">
<li><p>Iterate in C, Fortran, or “Fastest” (default) order.</p></li>
<li><p>Track a C-style or Fortran-style flat index if requested
(existing iterator always tracks a C-style index).  This can be done
independently of the iteration order.</p></li>
<li><p>Track the coordinates if requested (the existing iterator requires
manually changing an internal iterator flag to guarantee this).</p></li>
<li><p>Skip iteration of the last internal dimension so that it can be
processed with an inner loop.</p></li>
<li><p>Jump to a specific coordinate in the array.</p></li>
<li><p>Iterate an arbitrary subset of axes (to support, for example, reduce
with multiple axes at once).</p></li>
<li><p>Ability to automatically allocate output parameters if a NULL input
is provided,  These outputs should have a memory layout matching
the iteration order, and are the mechanism for the <code class="docutils literal notranslate"><span class="pre">order='K'</span></code>
support.</p></li>
<li><p>Automatic copying and/or buffering of inputs which do not satisfy
type/byte-order/alignment requirements.  The caller’s iteration inner
loop should be the same no matter what buffering or copying is done.</p></li>
</ul>
<p>Notes for implementation:</p>
<ul class="simple">
<li><p>User code must never touch the inside of the iterator. This allows
for drastic changes of the internal memory layout in the future, if
higher-performance implementation strategies are found.</p></li>
<li><p>Use a function pointer instead of a macro for iteration.
This way, specializations can be created for the common cases,
like when ndim is small, for different flag settings, and when the
number of arrays iterated is small.  Also, an iteration pattern
can be prescribed that makes a copy of the function pointer first
to allow the compiler to keep the function pointer
in a register.</p></li>
<li><p>Dynamically create the memory layout, to minimize the number of
cache lines taken up by the iterator (for LP64,
sizeof(PyArrayIterObject) is about 2.5KB, and a binary operation
like plus needs three of these for the Multi-Iterator).</p></li>
<li><p>Isolate the C-API object from Python reference counting, so that
it can be used naturally from C.  The Python object then becomes
a wrapper around the C iterator.  This is analogous to the
PEP 3118 design separation of Py_buffer and memoryview.</p></li>
</ul>
</section>
<section id="proposed-iterator-memory-layout">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Proposed iterator memory layout</a><a class="headerlink" href="#proposed-iterator-memory-layout" title="Link to this heading">#</a></h3>
<p>The following struct describes the iterator memory.  All items
are packed together, which means that different values of the flags,
ndim, and niter will produce slightly different layouts.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Flags indicate what optimizations have been applied, and</span>
<span class="cm">     * affect the layout of this struct. */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w"> </span><span class="n">itflags</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Number of iteration dimensions.  If FLAGS_HASCOORDS is set,</span>
<span class="cm">     * it matches the creation ndim, otherwise it may be smaller.  */</span>
<span class="w">    </span><span class="n">uint16</span><span class="w"> </span><span class="n">ndim</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Number of objects being iterated.  This is fixed at creation time. */</span>
<span class="w">    </span><span class="n">uint16</span><span class="w"> </span><span class="n">niter</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The number of times the iterator will iterate */</span>
<span class="w">    </span><span class="n">intp</span><span class="w"> </span><span class="n">itersize</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The permutation is only used when FLAGS_HASCOORDS is set,</span>
<span class="cm">     * and is placed here so its position depends on neither ndim</span>
<span class="cm">     * nor niter. */</span>
<span class="w">    </span><span class="n">intp</span><span class="w"> </span><span class="n">perm</span><span class="p">[</span><span class="n">ndim</span><span class="p">];</span>

<span class="w">    </span><span class="cm">/* The data types of all the operands */</span>
<span class="w">    </span><span class="n">PyArray_Descr</span><span class="w"> </span><span class="o">*</span><span class="n">dtypes</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">    </span><span class="cm">/* Backups of the starting axisdata &#39;ptr&#39; values, to support Reset */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">resetdataptr</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">    </span><span class="cm">/* Backup of the starting index value, to support Reset */</span>
<span class="w">    </span><span class="n">npy_intp</span><span class="w"> </span><span class="n">resetindex</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* When the iterator is destroyed, Py_XDECREF is called on all</span>
<span class="cm">       these objects */</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">objects</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>

<span class="w">    </span><span class="cm">/* Flags indicating read/write status and buffering</span>
<span class="cm">     * for each operand. */</span>
<span class="w">    </span><span class="n">uint8</span><span class="w"> </span><span class="n">opitflags</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">    </span><span class="cm">/* Padding to make things intp-aligned again */</span>
<span class="w">    </span><span class="n">uint8</span><span class="w"> </span><span class="n">padding</span><span class="p">[];</span>

<span class="w">    </span><span class="cm">/* If some or all of the inputs are being buffered */</span>
<span class="w">    </span><span class="cp">#if (flags&amp;FLAGS_BUFFERED)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The size of the buffer, and which buffer we&#39;re on.</span>
<span class="cm">         * the i-th iteration has i = buffersize*bufferindex+pos</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">buffersize</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* For tracking position inside the buffer */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* The strides for the pointers */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="cm">/* Pointers to the data for the current iterator position.</span>
<span class="cm">         * The buffer_data.value ptr[i] equals either</span>
<span class="cm">         * axis_data[0].ptr[i] or buffer_data.buffers[i] depending</span>
<span class="cm">         * on whether copying to the buffer was necessary.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="cm">/* Functions to do the copyswap and casting necessary */</span>
<span class="w">        </span><span class="n">transferfn_t</span><span class="w"> </span><span class="n">readtransferfn</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">readtransferdata</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="n">transferfn_t</span><span class="w"> </span><span class="n">writetransferfn</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">writetransferdata</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="cm">/* Pointers to the allocated buffers for operands</span>
<span class="cm">         * which the iterator determined needed buffering</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffers</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="cp">#endif </span><span class="cm">/* FLAGS_BUFFERED */</span>

<span class="w">    </span><span class="cm">/* Data per axis, starting with the most-frequently</span>
<span class="cm">     * updated, and in decreasing order after that. */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">axis_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* The shape of this axis */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* The current coordinate along this axis */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">coord</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* The operand and index strides for this axis */</span>
<span class="w">        </span><span class="n">intp</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="cp">#if (flags&amp;FLAGS_HASINDEX)</span>
<span class="w">            </span><span class="n">intp</span><span class="w"> </span><span class="n">indexstride</span><span class="p">;</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">        </span><span class="cm">/* The operand pointers and index values for this axis */</span>
<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">niter</span><span class="p">];</span>
<span class="w">        </span><span class="cp">#if (flags&amp;FLAGS_HASINDEX)</span>
<span class="w">            </span><span class="n">intp</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">        </span><span class="cp">#endif</span>
<span class="w">    </span><span class="p">}[</span><span class="n">ndim</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The array of axis_data structs is ordered to be in increasing rapidity
of increment updates.  If the <code class="docutils literal notranslate"><span class="pre">perm</span></code> is the identity, this means it’s
reversed from the C-order.  This is done so data items touched
most often are closest to the beginning of the struct, where the
common properties are, resulting in increased cache coherency.
It also simplifies the iternext call, while making getcoord and
related functions slightly more complicated.</p>
</section>
<section id="proposed-iterator-api">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Proposed iterator API</a><a class="headerlink" href="#proposed-iterator-api" title="Link to this heading">#</a></h3>
<p>The existing iterator API includes functions like PyArrayIter_Check,
PyArray_Iter* and PyArray_ITER_*.  The multi-iterator array includes
PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest.  The
new iterator design replaces all of this functionality with a single object
and associated API.  One goal of the new API is that all uses of the
existing iterator should be replaceable with the new iterator without
significant effort.</p>
<p>The C-API naming convention chosen is based on the one in the numpy-refactor
branch, where libndarray has the array named <code class="docutils literal notranslate"><span class="pre">NpyArray</span></code> and functions
named <code class="docutils literal notranslate"><span class="pre">NpyArray_*</span></code>.  The iterator is named <code class="docutils literal notranslate"><span class="pre">NpyIter</span></code> and functions are
named <code class="docutils literal notranslate"><span class="pre">NpyIter_*</span></code>.</p>
<p>The Python exposure has the iterator named <code class="docutils literal notranslate"><span class="pre">np.nditer</span></code>.  One possible
release strategy for this iterator would be to release a 1.X (1.6?) version
with the iterator added, but not used by the NumPy code.  Then, 2.0 can
be release with it fully integrated.  If this strategy is chosen, the
naming convention and API should be finalized as much as possible before
the 1.X release.  The name <code class="docutils literal notranslate"><span class="pre">np.iter</span></code> can’t be used because it conflicts
with the Python built-in <code class="docutils literal notranslate"><span class="pre">iter</span></code>.  I would suggest the name <code class="docutils literal notranslate"><span class="pre">np.nditer</span></code>
within Python, as it is currently unused.</p>
<p>In addition to the performance goals set out for the new iterator,
it appears the API can be refactored to better support some common
NumPy programming idioms.</p>
<p>By moving some functionality currently in the UFunc code into the
iterator, it should make it easier for extension code which wants
to emulate UFunc behavior in cases which don’t quite fit the
UFunc paradigm.  In particular, emulating the UFunc buffering behavior
is not a trivial enterprise.</p>
<section id="old-new-iterator-api-conversion">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Old -&gt; new iterator API conversion</a><a class="headerlink" href="#old-new-iterator-api-conversion" title="Link to this heading">#</a></h4>
<p>For the regular iterator:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_IterNew</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_New</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_IterAllButAxis</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_New</span></code> + <code class="docutils literal notranslate"><span class="pre">axes</span></code> parameter <strong>or</strong>
Iterator flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_BroadcastToShape</span></code></p></td>
<td><p><strong>NOT SUPPORTED</strong> (but could be, if needed)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArrayIter_Check</span></code></p></td>
<td><p>Will need to add this in Python exposure</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_RESET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_NEXT</span></code></p></td>
<td><p>Function pointer from <code class="docutils literal notranslate"><span class="pre">NpyIter_GetIterNext</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_DATA</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GetDataPtrArray</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GotoCoords</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO1D</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GotoIndex</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ITER_NOTDONE</span></code></p></td>
<td><p>Return value of <code class="docutils literal notranslate"><span class="pre">iternext</span></code> function pointer</p></td>
</tr>
</tbody>
</table>
</div>
<p>For the multi-iterator:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIterNew</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_RESET</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_NEXT</span></code></p></td>
<td><p>Function pointer from <code class="docutils literal notranslate"><span class="pre">NpyIter_GetIterNext</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_DATA</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GetDataPtrArray</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_NEXTi</span></code></p></td>
<td><p><strong>NOT SUPPORTED</strong> (always lock-step iteration)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_GOTO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GotoCoords</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_GOTO1D</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NpyIter_GotoIndex</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_MultiIter_NOTDONE</span></code></p></td>
<td><p>Return value of <code class="docutils literal notranslate"><span class="pre">iternext</span></code> function pointer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_Broadcast</span></code></p></td>
<td><p>Handled by <code class="docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_RemoveSmallest</span></code></p></td>
<td><p>Iterator flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>For other API calls:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PyArray_ConvertToCommonType</span></code></p></td>
<td><p>Iterator flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COMMON_DTYPE</span></code></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="iterator-pointer-type">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Iterator pointer type</a><a class="headerlink" href="#iterator-pointer-type" title="Link to this heading">#</a></h4>
<p>The iterator structure is internally generated, but a type is still needed
to provide warnings and/or errors when the wrong type is passed to
the API.  We do this with a typedef of an incomplete struct</p>
<p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span> <span class="pre">NpyIter_InternalOnly</span> <span class="pre">NpyIter;</span></code></p>
</section>
<section id="construction-and-destruction">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">Construction and destruction</a><a class="headerlink" href="#construction-and-destruction" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">NpyIter*</span> <span class="pre">NpyIter_New(PyArrayObject*</span> <span class="pre">op,</span> <span class="pre">npy_uint32</span> <span class="pre">flags,</span> <span class="pre">NPY_ORDER</span> <span class="pre">order,</span> <span class="pre">NPY_CASTING</span> <span class="pre">casting,</span> <span class="pre">PyArray_Descr*</span> <span class="pre">dtype,</span> <span class="pre">npy_intp</span> <span class="pre">a_ndim,</span> <span class="pre">npy_intp</span> <span class="pre">*axes,</span> <span class="pre">npy_intp</span> <span class="pre">buffersize)</span></code></p>
<blockquote>
<div><p>Creates an iterator for the given numpy array object <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">flags</span></code> are any combination
of the global and per-operand flags documented in
<code class="docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code>, except for <code class="docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code>.</p>
<p>Any of the <code class="docutils literal notranslate"><span class="pre">NPY_ORDER</span></code> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">order</span></code>.  For
efficient iteration, <code class="docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code> is the best option, and the other
orders enforce the particular iteration pattern.</p>
<p>Any of the <code class="docutils literal notranslate"><span class="pre">NPY_CASTING</span></code> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">casting</span></code>.
The values include <code class="docutils literal notranslate"><span class="pre">NPY_NO_CASTING</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_EQUIV_CASTING</span></code>,
<code class="docutils literal notranslate"><span class="pre">NPY_SAFE_CASTING</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_SAME_KIND_CASTING</span></code>, and
<code class="docutils literal notranslate"><span class="pre">NPY_UNSAFE_CASTING</span></code>.  To allow the casts to occur, copying or
buffering must also be enabled.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dtype</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then it requires that data type.
If copying is allowed, it will make a temporary copy if the data
is castable.  If <code class="docutils literal notranslate"><span class="pre">UPDATEIFCOPY</span></code> is enabled, it will also copy
the data back with another cast upon iterator destruction.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a_ndim</span></code> is greater than zero, <code class="docutils literal notranslate"><span class="pre">axes</span></code> must also be provided.
In this case, <code class="docutils literal notranslate"><span class="pre">axes</span></code> is an <code class="docutils literal notranslate"><span class="pre">a_ndim</span></code>-sized array of <code class="docutils literal notranslate"><span class="pre">op</span></code>’s axes.
A value of -1 in <code class="docutils literal notranslate"><span class="pre">axes</span></code> means <code class="docutils literal notranslate"><span class="pre">newaxis</span></code>. Within the <code class="docutils literal notranslate"><span class="pre">axes</span></code>
array, axes may not be repeated.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">buffersize</span></code> is zero, a default buffer size is used,
otherwise it specifies how big of a buffer to use.  Buffers
which are powers of 2 such as 512 or 1024 are recommended.</p>
<p>Returns NULL if there is an error, otherwise returns the allocated
iterator.</p>
<p>To make an iterator similar to the old iterator, this should work.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_New</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_ITER_READWRITE</span><span class="p">,</span>
<span class="w">                    </span><span class="n">NPY_CORDER</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_NO_CASTING</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to edit an array with aligned <code class="docutils literal notranslate"><span class="pre">double</span></code> code,
but the order doesn’t matter, you would use this.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_DescrFromType</span><span class="p">(</span><span class="n">NPY_DOUBLE</span><span class="p">);</span>
<span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_New</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_ITER_READWRITE</span><span class="w"> </span><span class="o">|</span>
<span class="w">                    </span><span class="n">NPY_ITER_BUFFERED</span><span class="w"> </span><span class="o">|</span>
<span class="w">                    </span><span class="n">NPY_ITER_NBO</span><span class="p">,</span>
<span class="w">                    </span><span class="n">NPY_ITER_ALIGNED</span><span class="p">,</span>
<span class="w">                    </span><span class="n">NPY_KEEPORDER</span><span class="p">,</span>
<span class="w">                    </span><span class="n">NPY_SAME_KIND_CASTING</span><span class="p">,</span>
<span class="w">                    </span><span class="n">dtype</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dtype</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NpyIter*</span> <span class="pre">NpyIter_MultiNew(npy_intp</span> <span class="pre">niter,</span> <span class="pre">PyArrayObject**</span> <span class="pre">op,</span> <span class="pre">npy_uint32</span> <span class="pre">flags,</span> <span class="pre">NPY_ORDER</span> <span class="pre">order,</span> <span class="pre">NPY_CASTING</span> <span class="pre">casting,</span> <span class="pre">npy_uint32</span> <span class="pre">*op_flags,</span> <span class="pre">PyArray_Descr**</span> <span class="pre">op_dtypes,</span> <span class="pre">npy_intp</span> <span class="pre">oa_ndim,</span> <span class="pre">npy_intp</span> <span class="pre">**op_axes,</span> <span class="pre">npy_intp</span> <span class="pre">buffersize)</span></code></p>
<blockquote>
<div><p>Creates an iterator for broadcasting the <code class="docutils literal notranslate"><span class="pre">niter</span></code> array objects provided
in <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
<p>For normal usage, use 0 for <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code> and NULL for <code class="docutils literal notranslate"><span class="pre">op_axes</span></code>.
See below for a description of these parameters, which allow for
custom manual broadcasting as well as reordering and leaving out axes.</p>
<p>Any of the <code class="docutils literal notranslate"><span class="pre">NPY_ORDER</span></code> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">order</span></code>.  For
efficient iteration, <code class="docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code> is the best option, and the other
orders enforce the particular iteration pattern.  When using
<code class="docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code>, if you also want to ensure that the iteration is
not reversed along an axis, you should pass the flag
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_DONT_NEGATE_STRIDES</span></code>.</p>
<p>Any of the <code class="docutils literal notranslate"><span class="pre">NPY_CASTING</span></code> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">casting</span></code>.
The values include <code class="docutils literal notranslate"><span class="pre">NPY_NO_CASTING</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_EQUIV_CASTING</span></code>,
<code class="docutils literal notranslate"><span class="pre">NPY_SAFE_CASTING</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_SAME_KIND_CASTING</span></code>, and
<code class="docutils literal notranslate"><span class="pre">NPY_UNSAFE_CASTING</span></code>.  To allow the casts to occur, copying or
buffering must also be enabled.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">op_dtypes</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, it specifies a data type or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
for each <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>, when non-zero, specifies the number of
dimensions that will be iterated with customized broadcasting.
If it is provided, <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> must also be provided.
These two parameters let you control in detail how the
axes of the operand arrays get matched together and iterated.
In <code class="docutils literal notranslate"><span class="pre">op_axes</span></code>, you must provide an array of <code class="docutils literal notranslate"><span class="pre">niter</span></code> pointers
to <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>-sized arrays of type <code class="docutils literal notranslate"><span class="pre">npy_intp</span></code>.  If an entry
in <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> is NULL, normal broadcasting rules will apply.
In <code class="docutils literal notranslate"><span class="pre">op_axes[j][i]</span></code> is stored either a valid axis of <code class="docutils literal notranslate"><span class="pre">op[j]</span></code>, or
-1 which means <code class="docutils literal notranslate"><span class="pre">newaxis</span></code>.  Within each <code class="docutils literal notranslate"><span class="pre">op_axes[j]</span></code> array, axes
may not be repeated.  The following example is how normal broadcasting
applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span><span class="w"> </span><span class="n">oa_ndim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">               </span><span class="cm">/* # iteration axes */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">op0_axes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w">    </span><span class="cm">/* 3-D operand */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">op1_axes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span><span class="w">   </span><span class="cm">/* 2-D operand */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">op2_axes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w">  </span><span class="cm">/* 1-D operand */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">op3_axes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">}</span><span class="w">  </span><span class="cm">/* 0-D (scalar) operand */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">op_axes</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">op0_axes</span><span class="p">,</span><span class="w"> </span><span class="n">op1_axes</span><span class="p">,</span><span class="w"> </span><span class="n">op2_axes</span><span class="p">,</span><span class="w"> </span><span class="n">op3_axes</span><span class="p">};</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">buffersize</span></code> is zero, a default buffer size is used,
otherwise it specifies how big of a buffer to use.  Buffers
which are powers of 2 such as 512 or 1024 are recommended.</p>
<p>Returns NULL if there is an error, otherwise returns the allocated
iterator.</p>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">flags</span></code>, applying to the whole
iterator, are:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></p>
<blockquote>
<div><p>Causes the iterator to track an index matching C or
Fortran order. These options are mutually exclusive.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code></p>
<blockquote>
<div><p>Causes the iterator to track array coordinates.
This prevents the iterator from coalescing axes to
produce bigger inner loops.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code></p>
<blockquote>
<div><p>Causes the iterator to skip iteration of the innermost
loop, allowing the user of the iterator to handle it.</p>
<p>This flag is incompatible with <code class="docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code>,
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code>, and <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_DONT_NEGATE_STRIDES</span></code></p>
<blockquote>
<div><p>This only affects the iterator when NPY_KEEPORDER is specified
for the order parameter.  By default with NPY_KEEPORDER, the
iterator reverses axes which have negative strides, so that
memory is traversed in a forward direction.  This disables
this step.  Use this flag if you want to use the underlying
memory-ordering of the axes, but don’t want an axis reversed.
This is the behavior of <code class="docutils literal notranslate"><span class="pre">numpy.ravel(a,</span> <span class="pre">order='K')</span></code>, for
instance.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_COMMON_DTYPE</span></code></p>
<blockquote>
<div><p>Causes the iterator to convert all the operands to a common
data type, calculated based on the ufunc type promotion rules.
The flags for each operand must be set so that the appropriate
casting is permitted, and copying or buffering must be enabled.</p>
<p>If the common data type is known ahead of time, don’t use this
flag.  Instead, set the requested dtype for all the operands.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_REFS_OK</span></code></p>
<blockquote>
<div><p>Indicates that arrays with reference types (object
arrays or structured arrays containing an object type)
may be accepted and used in the iterator.  If this flag
is enabled, the caller must be sure to check whether
<code class="docutils literal notranslate"><span class="pre">NpyIter_IterationNeedsAPI(iter)</span></code> is true, in which case
it may not release the GIL during iteration.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_ZEROSIZE_OK</span></code></p>
<blockquote>
<div><p>Indicates that arrays with a size of zero should be permitted.
Since the typical iteration loop does not naturally work with
zero-sized arrays, you must check that the IterSize is non-zero
before entering the iteration loop.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_REDUCE_OK</span></code></p>
<blockquote>
<div><p>Permits writeable operands with a dimension with zero
stride and size greater than one.  Note that such operands
must be read/write.</p>
<p>When buffering is enabled, this also switches to a special
buffering mode which reduces the loop length as necessary to
not trample on values being reduced.</p>
<p>Note that if you want to do a reduction on an automatically
allocated output, you must use <code class="docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code>
to get its reference, then set every value to the reduction
unit before doing the iteration loop.  In the case of a
buffered reduction, this means you must also specify the
flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code>, then reset the iterator
after initializing the allocated operand to prepare the
buffers.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code></p>
<blockquote>
<div><p>Enables support for iteration of sub-ranges of the full
<code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_IterSize(iter))</span></code>.  Use
the function <code class="docutils literal notranslate"><span class="pre">NpyIter_ResetToIterIndexRange</span></code> to specify
a range for iteration.</p>
<p>This flag can only be used with <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>
when <code class="docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code> is enabled.  This is because
without buffering, the inner loop is always the size of the
innermost iteration dimension, and allowing it to get cut up
would require special handling, effectively making it more
like the buffered version.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code></p>
<blockquote>
<div><p>Causes the iterator to store buffering data, and use buffering
to satisfy data type, alignment, and byte-order requirements.
To buffer an operand, do not specify the <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code>
or <code class="docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code> flags, because they will
override buffering.  Buffering is especially useful for Python
code using the iterator, allowing for larger chunks
of data at once to amortize the Python interpreter overhead.</p>
<p>If used with <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>, the inner loop
for the caller may get larger chunks than would be possible
without buffering, because of how the strides are laid out.</p>
<p>Note that if an operand is given the flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code>
or <code class="docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code>, a copy will be made in preference
to buffering.  Buffering will still occur when the array was
broadcast so elements need to be duplicated to get a constant
stride.</p>
<p>In normal buffering, the size of each inner loop is equal
to the buffer size, or possibly larger if <code class="docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code>
is specified.  If <code class="docutils literal notranslate"><span class="pre">NPY_ITER_REDUCE_OK</span></code> is enabled and
a reduction occurs, the inner loops may become smaller depending
on the structure of the reduction.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code></p>
<blockquote>
<div><p>When buffering is enabled, this allows the size of the inner
loop to grow when buffering isn’t necessary.  This option
is best used if you’re doing a straight pass through all the
data, rather than anything with small cache-friendly arrays
of temporary values for each inner loop.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code></p>
<blockquote>
<div><p>When buffering is enabled, this delays allocation of the
buffers until one of the <code class="docutils literal notranslate"><span class="pre">NpyIter_Reset*</span></code> functions is
called.  This flag exists to avoid wasteful copying of
buffer data when making multiple copies of a buffered
iterator for multi-threaded iteration.</p>
<p>Another use of this flag is for setting up reduction operations.
After the iterator is created, and a reduction output
is allocated automatically by the iterator (be sure to use
READWRITE access), its value may be initialized to the reduction
unit.  Use <code class="docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code> to get the object.
Then, call <code class="docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code> to allocate and fill the buffers
with their initial values.</p>
</div></blockquote>
</div></blockquote>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">op_flags[i]</span></code>, where <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">niter</span></code>:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_READWRITE</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_READONLY</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_WRITEONLY</span></code></p>
<blockquote>
<div><p>Indicate how the user of the iterator will read or write
to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>.  Exactly one of these flags must be specified
per operand.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code></p>
<blockquote>
<div><p>Allow a copy of <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> to be made if it does not
meet the data type or alignment requirements as specified
by the constructor flags and parameters.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code></p>
<blockquote>
<div><p>Triggers <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code>, and when an array operand
is flagged for writing and is copied, causes the data
in a copy to be copied back to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> when the iterator
is destroyed.</p>
<p>If the operand is flagged as write-only and a copy is needed,
an uninitialized temporary array will be created and then copied
to back to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> on destruction, instead of doing
the unnecessary copy operation.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_NBO</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_ALIGNED</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_CONTIG</span></code></p>
<blockquote>
<div><p>Causes the iterator to provide data for <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>
that is in native byte order, aligned according to
the dtype requirements, contiguous, or any combination.</p>
<p>By default, the iterator produces pointers into the
arrays provided, which may be aligned or unaligned, and
with any byte order.  If copying or buffering is not
enabled and the operand data doesn’t satisfy the constraints,
an error will be raised.</p>
<p>The contiguous constraint applies only to the inner loop,
successive inner loops may have arbitrary pointer changes.</p>
<p>If the requested data type is in non-native byte order,
the NBO flag overrides it and the requested data type is
converted to be in native byte order.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code></p>
<blockquote>
<div><p>This is for output arrays, and requires that the flag
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_WRITEONLY</span></code> be set.  If <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> is NULL,
creates a new array with the final broadcast dimensions,
and a layout matching the iteration order of the iterator.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> is NULL, the requested data type
<code class="docutils literal notranslate"><span class="pre">op_dtypes[i]</span></code> may be NULL as well, in which case it is
automatically generated from the dtypes of the arrays which
are flagged as readable.  The rules for generating the dtype
are the same is for UFuncs.  Of special note is handling
of byte order in the selected dtype.  If there is exactly
one input, the input’s dtype is used as is.  Otherwise,
if more than one input dtypes are combined together, the
output will be in native byte order.</p>
<p>After being allocated with this flag, the caller may retrieve
the new array by calling <code class="docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code> and
getting the i-th object in the returned C array.  The caller
must call Py_INCREF on it to claim a reference to the array.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_SUBTYPE</span></code></p>
<blockquote>
<div><p>For use with <code class="docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code>, this flag disables
allocating an array subtype for the output, forcing
it to be a straight ndarray.</p>
<p>TODO: Maybe it would be better to introduce a function
<code class="docutils literal notranslate"><span class="pre">NpyIter_GetWrappedOutput</span></code> and remove this flag?</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_BROADCAST</span></code></p>
<blockquote>
<div><p>Ensures that the input or output matches the iteration
dimensions exactly.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NPY_ITER_WRITEABLE_REFERENCES</span></code></p>
<blockquote>
<div><p>By default, the iterator fails on creation if the iterator
has a writeable operand where the data type involves Python
references.  Adding this flag indicates that the code using
the iterator is aware of this possibility and handles it
correctly.</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NpyIter</span> <span class="pre">*NpyIter_Copy(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Makes a copy of the given iterator.  This function is provided
primarily to enable multi-threaded iteration of the data.</p>
<p><em>TODO</em>: Move this to a section about multithreaded iteration.</p>
<p>The recommended approach to multithreaded iteration is to
first create an iterator with the flags
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code>,
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code>, and
possibly <code class="docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code>.  Create a copy of this iterator
for each thread (minus one for the first iterator).  Then, take
the iteration index range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_GetIterSize(iter))</span></code> and
split it up into tasks, for example using a TBB parallel_for loop.
When a thread gets a task to execute, it then uses its copy of
the iterator by calling <code class="docutils literal notranslate"><span class="pre">NpyIter_ResetToIterIndexRange</span></code> and
iterating over the full range.</p>
<p>When using the iterator in multi-threaded code or in code not
holding the Python GIL, care must be taken to only call functions
which are safe in that context.  <code class="docutils literal notranslate"><span class="pre">NpyIter_Copy</span></code> cannot be safely
called without the Python GIL, because it increments Python
references.  The <code class="docutils literal notranslate"><span class="pre">Reset*</span></code> and some other functions may be safely
called by passing in the <code class="docutils literal notranslate"><span class="pre">errmsg</span></code> parameter as non-NULL, so that
the functions will pass back errors through it instead of setting
a Python exception.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_UpdateIter(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">i,</span> <span class="pre">npy_uint32</span> <span class="pre">op_flags,</span> <span class="pre">NPY_CASTING</span> <span class="pre">casting,</span> <span class="pre">PyArray_Descr</span> <span class="pre">*dtype)</span></code> <strong>UNIMPLEMENTED</strong></p>
<blockquote>
<div><p>Updates the i-th operand within the iterator to possibly have a new
data type or more restrictive flag attributes.  A use-case for
this is to allow the automatic allocation to determine an
output data type based on the standard NumPy type promotion rules,
then use this function to convert the inputs and possibly the
automatic output to a different data type during processing.</p>
<p>This operation can only be done if <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code> was passed
as a flag to the iterator.  If coordinates are not needed,
call the function <code class="docutils literal notranslate"><span class="pre">NpyIter_RemoveCoords()</span></code> once no more calls to
<code class="docutils literal notranslate"><span class="pre">NpyIter_UpdateIter</span></code> are needed.</p>
<p>If the i-th operand has already been copied, an error is thrown.  To
avoid this, leave all the flags out except the read/write indicators
for any operand that later has <code class="docutils literal notranslate"><span class="pre">NpyIter_UpdateIter</span></code> called on it.</p>
<p>The flags that may be passed in <code class="docutils literal notranslate"><span class="pre">op_flags</span></code> are
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code>,
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_NBO</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_ALIGNED</span></code>, <code class="docutils literal notranslate"><span class="pre">NPY_ITER_CONTIG</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_RemoveAxis(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>Removes an axis from iteration.  This requires that
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code> was set for iterator creation, and does not work
if buffering is enabled or an index is being tracked. This function
also resets the iterator to its initial state.</p>
<p>This is useful for setting up an accumulation loop, for example.
The iterator can first be created with all the dimensions, including
the accumulation axis, so that the output gets created correctly.
Then, the accumulation axis can be removed, and the calculation
done in a nested fashion.</p>
<p><strong>WARNING</strong>: This function may change the internal memory layout of
the iterator.  Any cached functions or pointers from the iterator
must be retrieved again!</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_RemoveCoords(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>If the iterator has coordinates, this strips support for them, and
does further iterator optimizations that are possible if coordinates
are not needed.  This function also resets the iterator to its initial
state.</p>
<p><strong>WARNING</strong>: This function may change the internal memory layout of
the iterator.  Any cached functions or pointers from the iterator
must be retrieved again!</p>
<p>After calling this function, <code class="docutils literal notranslate"><span class="pre">NpyIter_HasCoords(iter)</span></code> will
return false.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_RemoveInnerLoop(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>If UpdateIter/RemoveCoords was used, you may want to specify the
flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>.  This flag is not permitted
together with <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code>, so this function is provided
to enable the feature after <code class="docutils literal notranslate"><span class="pre">NpyIter_RemoveCoords</span></code> is called.
This function also resets the iterator to its initial state.</p>
<p><strong>WARNING</strong>: This function changes the internal logic of the iterator.
Any cached functions or pointers from the iterator must be retrieved
again!</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_Deallocate(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Deallocates the iterator object.  This additionally frees any
copies made, triggering UPDATEIFCOPY behavior where necessary.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_Reset(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">**errmsg)</span></code></p>
<blockquote>
<div><p>Resets the iterator back to its initial state, at the beginning
of the iteration range.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_ResetToIterIndexRange(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">istart,</span> <span class="pre">npy_intp</span> <span class="pre">iend,</span> <span class="pre">char</span> <span class="pre">**errmsg)</span></code></p>
<blockquote>
<div><p>Resets the iterator and restricts it to the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range
<code class="docutils literal notranslate"><span class="pre">[istart,</span> <span class="pre">iend)</span></code>.  See <code class="docutils literal notranslate"><span class="pre">NpyIter_Copy</span></code> for an explanation of
how to use this for multi-threaded iteration.  This requires that
the flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code> was passed to the iterator constructor.</p>
<p>If you want to reset both the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range and the base
pointers at the same time, you can do the following to avoid
extra buffer copying (be sure to add the return code error checks
when you copy this code).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Set to a trivial empty range */</span>
<span class="n">NpyIter_ResetToIterIndexRange</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* Set the base pointers */</span>
<span class="n">NpyIter_ResetBasePointers</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">baseptrs</span><span class="p">);</span>
<span class="cm">/* Set to the desired range */</span>
<span class="n">NpyIter_ResetToIterIndexRange</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">istart</span><span class="p">,</span><span class="w"> </span><span class="n">iend</span><span class="p">);</span>
</pre></div>
</div>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_ResetBasePointers(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">**baseptrs,</span> <span class="pre">char</span> <span class="pre">**errmsg)</span></code></p>
<blockquote>
<div><p>Resets the iterator back to its initial state, but using the values
in <code class="docutils literal notranslate"><span class="pre">baseptrs</span></code> for the data instead of the pointers from the arrays
being iterated.  This functions is intended to be used, together with
the <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> parameter, by nested iteration code with two or more
iterators.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
<p><em>TODO</em>: Move the following into a special section on nested iterators.</p>
<p>Creating iterators for nested iteration requires some care.  All
the iterator operands must match exactly, or the calls to
<code class="docutils literal notranslate"><span class="pre">NpyIter_ResetBasePointers</span></code> will be invalid.  This means that
automatic copies and output allocation should not be used haphazardly.
It is possible to still use the automatic data conversion and casting
features of the iterator by creating one of the iterators with
all the conversion parameters enabled, then grabbing the allocated
operands with the <code class="docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code> function and passing
them into the constructors for the rest of the iterators.</p>
<p><strong>WARNING</strong>: When creating iterators for nested iteration,
the code must not use a dimension more than once in the different
iterators.  If this is done, nested iteration will produce
out-of-bounds pointers during iteration.</p>
<p><strong>WARNING</strong>: When creating iterators for nested iteration, buffering
can only be applied to the innermost iterator.  If a buffered iterator
is used as the source for <code class="docutils literal notranslate"><span class="pre">baseptrs</span></code>, it will point into a small buffer
instead of the array and the inner iteration will be invalid.</p>
<p>The pattern for using nested iterators is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span><span class="w"> </span><span class="o">*</span><span class="n">iter1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">iter1</span><span class="p">;</span>
<span class="n">NpyIter_IterNext_Fn</span><span class="w"> </span><span class="n">iternext1</span><span class="p">,</span><span class="w"> </span><span class="n">iternext2</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dataptrs1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * With the exact same operands, no copies allowed, and</span>
<span class="cm"> * no axis in op_axes used both in iter1 and iter2.</span>
<span class="cm"> * Buffering may be enabled for iter2, but not for iter1.</span>
<span class="cm"> */</span>
<span class="n">iter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"> </span><span class="n">iter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="n">iternext1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span>
<span class="n">iternext2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter2</span><span class="p">);</span>
<span class="n">dataptrs1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NpyIter_ResetBasePointers</span><span class="p">(</span><span class="n">iter2</span><span class="p">,</span><span class="w"> </span><span class="n">dataptrs1</span><span class="p">);</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Use the iter2 values */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext2</span><span class="p">(</span><span class="n">iter2</span><span class="p">));</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext1</span><span class="p">(</span><span class="n">iter1</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_GotoCoords(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">*coords)</span></code></p>
<blockquote>
<div><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">ndim</span></code> coordinates
pointed to by <code class="docutils literal notranslate"><span class="pre">coords</span></code>.  Returns an error if coordinates
are not being tracked, the coordinates are out of bounds,
or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_GotoIndex(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">index)</span></code></p>
<blockquote>
<div><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">index</span></code> specified.
If the iterator was constructed with the flag
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code> is the C-order index,
and if the iterator was constructed with the flag
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code> is the Fortran-order
index.  Returns an error if there is no index being tracked,
the index is out of bounds, or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetIterSize(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns the number of elements being iterated.  This is the product
of all the dimensions in the shape.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetReduceBlockSizeFactor(NpyIter</span> <span class="pre">*iter)</span></code> <strong>UNIMPLEMENTED</strong></p>
<blockquote>
<div><p>This provides a factor that must divide into the blocksize used
for ranged iteration to safely multithread a reduction.  If
the iterator has no reduction, it returns 1.</p>
<p>When using ranged iteration to multithread a reduction, there are
two possible ways to do the reduction:</p>
<p>If there is a big reduction to a small output, make a temporary
array initialized to the reduction unit for each thread, then have
each thread reduce into its temporary.  When that is complete,
combine the temporaries together.  You can detect this case by
observing that <code class="docutils literal notranslate"><span class="pre">NpyIter_GetReduceBlockSizeFactor</span></code> returns a
large value, for instance half or a third of <code class="docutils literal notranslate"><span class="pre">NpyIter_GetIterSize</span></code>.
You should also check that the output is small just to be sure.</p>
<p>If there are many small reductions to a big output, and the reduction
dimensions are inner dimensions, <code class="docutils literal notranslate"><span class="pre">NpyIter_GetReduceBlockSizeFactor</span></code>
will return a small number, and as long as the block size you choose
for multithreading is <code class="docutils literal notranslate"><span class="pre">NpyIter_GetReduceBlockSizeFactor(iter)*n</span></code>
for some <code class="docutils literal notranslate"><span class="pre">n</span></code>, the operation will be safe.</p>
<p>The bad case is when the a reduction dimension is the outermost
loop in the iterator.  For example, if you have a C-order
array with shape (3,1000,1000), and you reduce on dimension 0,
<code class="docutils literal notranslate"><span class="pre">NpyIter_GetReduceBlockSizeFactor</span></code> will return a size equal to
<code class="docutils literal notranslate"><span class="pre">NpyIter_GetIterSize</span></code> for <code class="docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_CORDER</span></code>
iteration orders.  While it is bad for the CPU cache, perhaps
in the future another order possibility could be provided, maybe
<code class="docutils literal notranslate"><span class="pre">NPY_REDUCEORDER</span></code>, which pushes the reduction axes to the inner
loop, but otherwise is the same as <code class="docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetIterIndex(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Gets the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> of the iterator, which is an index matching
the iteration order of the iterator.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NpyIter_GetIterIndexRange(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">*istart,</span> <span class="pre">npy_intp</span> <span class="pre">*iend)</span></code></p>
<blockquote>
<div><p>Gets the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> sub-range that is being iterated.  If
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code> was not specified, this always returns the
range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_IterSize(iter))</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_GotoIterIndex(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">iterindex)</span></code></p>
<blockquote>
<div><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> specified.
The IterIndex is an index matching the iteration order of the iterator.
Returns an error if the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> is out of bounds,
buffering is enabled, or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_HasInnerLoop(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns 1 if the iterator handles the inner loop,
or 0 if the caller needs to handle it.  This is controlled
by the constructor flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_HasCoords(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns 1 if the iterator was created with the
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_COORDS</span></code> flag, 0 otherwise.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_HasIndex(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns 1 if the iterator was created with the
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code>
flag, 0 otherwise.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_IsBuffered(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns 1 if the iterator was created with the
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code> flag, 0 otherwise.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_IsGrowInner(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns 1 if the iterator was created with the
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code> flag, 0 otherwise.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetBufferSize(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>If the iterator is buffered, returns the size of the buffer
being used, otherwise returns 0.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetNDim(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns the number of dimensions being iterated.  If coordinates
were not requested in the iterator constructor, this value
may be smaller than the number of dimensions in the original
objects.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">NpyIter_GetNIter(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns the number of objects being iterated.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">*NpyIter_GetAxisStrideArray(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>Gets the array of strides for the specified axis. Requires that
the iterator be tracking coordinates, and that buffering not
be enabled.</p>
<p>This may be used when you want to match up operand axes in
some fashion, then remove them with <code class="docutils literal notranslate"><span class="pre">NpyIter_RemoveAxis</span></code> to
handle their processing manually.  By calling this function
before removing the axes, you can get the strides for the
manual processing.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">NpyIter_GetShape(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">*outshape)</span></code></p>
<blockquote>
<div><p>Returns the broadcast shape of the iterator in <code class="docutils literal notranslate"><span class="pre">outshape</span></code>.
This can only be called on an iterator which supports coordinates.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">PyArray_Descr</span> <span class="pre">**NpyIter_GetDescrArray(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">niter</span></code> data type Descrs for
the objects being iterated.  The result points into <code class="docutils literal notranslate"><span class="pre">iter</span></code>,
so the caller does not gain any references to the Descrs.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">**NpyIter_GetOperandArray(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">niter</span></code> operand PyObjects
that are being iterated.  The result points into <code class="docutils literal notranslate"><span class="pre">iter</span></code>,
so the caller does not gain any references to the PyObjects.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*NpyIter_GetIterView(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">i)</span></code></p>
<blockquote>
<div><p>This gives back a reference to a new ndarray view, which is a view
into the i-th object in the array <code class="docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray()</span></code>,
whose dimensions and strides match the internal optimized
iteration pattern.  A C-order iteration of this view is equivalent
to the iterator’s iteration order.</p>
<p>For example, if an iterator was created with a single array as its
input, and it was possible to rearrange all its axes and then
collapse it into a single strided iteration, this would return
a view that is a one-dimensional array.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NpyIter_GetReadFlags(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">*outreadflags)</span></code></p>
<blockquote>
<div><p>Fills <code class="docutils literal notranslate"><span class="pre">niter</span></code> flags. Sets <code class="docutils literal notranslate"><span class="pre">outreadflags[i]</span></code> to 1 if
<code class="docutils literal notranslate"><span class="pre">op[i]</span></code> can be read from, and to 0 if not.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NpyIter_GetWriteFlags(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">*outwriteflags)</span></code></p>
<blockquote>
<div><p>Fills <code class="docutils literal notranslate"><span class="pre">niter</span></code> flags. Sets <code class="docutils literal notranslate"><span class="pre">outwriteflags[i]</span></code> to 1 if
<code class="docutils literal notranslate"><span class="pre">op[i]</span></code> can be written to, and to 0 if not.</p>
</div></blockquote>
</section>
<section id="functions-for-iteration">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Functions for iteration</a><a class="headerlink" href="#functions-for-iteration" title="Link to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">NpyIter_IterNext_Fn</span> <span class="pre">NpyIter_GetIterNext(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">**errmsg)</span></code></p>
<blockquote>
<div><p>Returns a function pointer for iteration.  A specialized version
of the function pointer may be calculated by this function
instead of being stored in the iterator structure. Thus, to
get good performance, it is required that the function pointer
be saved in a variable rather than retrieved for each loop iteration.</p>
<p>Returns NULL if there is an error.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
<p>The typical looping construct is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_IterNext_Fn</span><span class="w"> </span><span class="n">iternext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dataptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* use the addresses dataptr[0], ... dataptr[niter-1] */</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code> is specified, the typical
inner loop construct is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_IterNext_Fn</span><span class="w"> </span><span class="n">iternext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dataptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">iiter</span><span class="p">,</span><span class="w"> </span><span class="n">niter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetNIter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* use the addresses dataptr[0], ... dataptr[niter-1] */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iiter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">niter</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataptr</span><span class="p">[</span><span class="n">iiter</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">iiter</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext</span><span class="p">());</span>
</pre></div>
</div>
<p>Observe that we are using the dataptr array inside the iterator, not
copying the values to a local temporary.  This is possible because
when <code class="docutils literal notranslate"><span class="pre">iternext()</span></code> is called, these pointers will be overwritten
with fresh values, not incrementally updated.</p>
<p>If a compile-time fixed buffer is being used (both flags
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code> and <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code>), the
inner size may be used as a signal as well.  The size is guaranteed
to become zero when <code class="docutils literal notranslate"><span class="pre">iternext()</span></code> returns false, enabling the
following loop construct.  Note that if you use this construct,
you should not pass <code class="docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code> as a flag, because it
will cause larger sizes under some circumstances:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* The constructor should have buffersize passed as this value */</span>
<span class="cp">#define FIXED_BUFFER_SIZE 1024</span>

<span class="n">NpyIter_IterNext_Fn</span><span class="w"> </span><span class="n">iternext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dataptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">iiter</span><span class="p">,</span><span class="w"> </span><span class="n">niter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetNIter</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="cm">/* One loop with a fixed inner size */</span>
<span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FIXED_BUFFER_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * This loop could be manually unrolled by a factor</span>
<span class="cm">     * which divides into FIXED_BUFFER_SIZE</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FIXED_BUFFER_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* use the addresses dataptr[0], ... dataptr[niter-1] */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iiter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">niter</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataptr</span><span class="p">[</span><span class="n">iiter</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">iiter</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">iternext</span><span class="p">();</span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Finish-up loop with variable inner size */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* use the addresses dataptr[0], ... dataptr[niter-1] */</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iiter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">niter</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iiter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dataptr</span><span class="p">[</span><span class="n">iiter</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">iiter</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext</span><span class="p">());</span>
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">NpyIter_GetCoords_Fn</span> <span class="pre">NpyIter_GetGetCoords(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">char</span> <span class="pre">**errmsg)</span></code></p>
<blockquote>
<div><p>Returns a function pointer for getting the coordinates
of the iterator.  Returns NULL if the iterator does not
support coordinates.  It is recommended that this function
pointer be cached in a local variable before the iteration
loop.</p>
<p>Returns NULL if there is an error.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**NpyIter_GetDataPtrArray(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">niter</span></code> data pointers.  If
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code> was not specified, each data
pointer points to the current data item of the iterator.  If
no inner iteration was specified, it points to the first data
item of the inner loop.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.  This function may be safely
called without holding the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">*NpyIter_GetIndexPtr(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>This gives back a pointer to the index being tracked, or NULL
if no index is being tracked.  It is only usable if one of
the flags <code class="docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code>
were specified during construction.</p>
</div></blockquote>
<p>When the flag <code class="docutils literal notranslate"><span class="pre">NPY_ITER_NO_INNER_ITERATION</span></code> is used, the code
needs to know the parameters for doing the inner loop.  These
functions provide that information.</p>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp</span> <span class="pre">*NpyIter_GetInnerStrideArray(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns a pointer to an array of the <code class="docutils literal notranslate"><span class="pre">niter</span></code> strides,
one for each iterated object, to be used by the inner loop.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it. This function may be safely
called without holding the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">npy_intp*</span> <span class="pre">NpyIter_GetInnerLoopSizePtr(NpyIter</span> <span class="pre">*iter)</span></code></p>
<blockquote>
<div><p>Returns a pointer to the number of iterations the
inner loop should execute.</p>
<p>This address may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.  The value itself may change during
iteration, in particular if buffering is enabled.  This function
may be safely called without holding the Python GIL.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">NpyIter_GetInnerFixedStrideArray(NpyIter</span> <span class="pre">*iter,</span> <span class="pre">npy_intp</span> <span class="pre">*out_strides)</span></code></p>
<blockquote>
<div><p>Gets an array of strides which are fixed, or will not change during
the entire iteration.  For strides that may change, the value
NPY_MAX_INTP is placed in the stride.</p>
<p>Once the iterator is prepared for iteration (after a reset if
<code class="docutils literal notranslate"><span class="pre">NPY_DELAY_BUFALLOC</span></code> was used), call this to get the strides
which may be used to select a fast inner loop function.  For example,
if the stride is 0, that means the inner loop can always load its
value into a variable once, then use the variable throughout the loop,
or if the stride equals the itemsize, a contiguous version for that
operand may be used.</p>
<p>This function may be safely called without holding the Python GIL.</p>
</div></blockquote>
</section>
<section id="examples">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Examples</a><a class="headerlink" href="#examples" title="Link to this heading">#</a></h4>
<p>A copy function using the iterator.  The <code class="docutils literal notranslate"><span class="pre">order</span></code> parameter
is used to control the memory layout of the allocated
result.</p>
<p>If the input is a reference type, this function will fail.
To fix this, the code must be changed to specially handle writeable
references, and add <code class="docutils literal notranslate"><span class="pre">NPY_ITER_WRITEABLE_REFERENCES</span></code> to the flags:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* NOTE: This code has not been compiled/tested */</span>
<span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">CopyArray</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_ORDER</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">NpyIter</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="w">    </span><span class="n">NpyIter_IterNext_Fn</span><span class="w"> </span><span class="n">iternext</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="n">npy_uint32</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">npy_uint32</span><span class="w"> </span><span class="n">op_flags</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">npy_intp</span><span class="w"> </span><span class="n">itemsize</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">innersizeptr</span><span class="p">,</span><span class="w"> </span><span class="n">innerstride</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dataptrarray</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * No inner iteration - inner loop is handled by CopyArray code</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NPY_ITER_NO_INNER_ITERATION</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Tell the constructor to automatically allocate the output.</span>
<span class="cm">     * The data type of the output will match that of the input.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span>
<span class="w">    </span><span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">op_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NPY_ITER_READONLY</span><span class="p">;</span>
<span class="w">    </span><span class="n">op_flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NPY_ITER_WRITEONLY</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NPY_ITER_ALLOCATE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Construct the iterator */</span>
<span class="w">    </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_MultiNew</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_NO_CASTING</span><span class="p">,</span>
<span class="w">                            </span><span class="n">op_flags</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Make a copy of the iternext function pointer and</span>
<span class="cm">     * a few other variables the inner loop needs.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">iternext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="n">innerstride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="n">itemsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDescrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">elsize</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * The inner loop size and data pointers may change during the</span>
<span class="cm">     * loop, so just cache the addresses.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">innersizeptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="n">dataptrarray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Note that because the iterator allocated the output,</span>
<span class="cm">     * it matches the iteration order and is packed tightly,</span>
<span class="cm">     * so we don&#39;t need to check it like the input.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">innerstride</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">itemsize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="n">dataptrarray</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">dataptrarray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="w">                                    </span><span class="n">itemsize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">innersizeptr</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Should specialize this further based on item size... */</span>
<span class="w">        </span><span class="n">npy_intp</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">npy_intp</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">innersizeptr</span><span class="p">;</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">innerstride</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">itemsize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">itemsize</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Get the result from the iterator object array */</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NpyIter_GetOperandArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">Py_INCREF</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NpyIter_Deallocate</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NPY_SUCCEED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="python-lambda-ufunc-example">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Python lambda UFunc example</a><a class="headerlink" href="#python-lambda-ufunc-example" title="Link to this heading">#</a></h4>
<p>To show how the new iterator allows the definition of efficient UFunc-like
functions in pure Python, we demonstrate the function <code class="docutils literal notranslate"><span class="pre">luf</span></code>, which
makes a lambda-expression act like a UFunc.  This is very similar to the
<code class="docutils literal notranslate"><span class="pre">numexpr</span></code> library, but only takes a few lines of code.</p>
<p>First, here is the definition of the <code class="docutils literal notranslate"><span class="pre">luf</span></code> function.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">luf</span><span class="p">(</span><span class="n">lamdaexpr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lambda UFunc</span>

<span class="sd">        e.g.</span>
<span class="sd">        c = luf(lambda i,j:i+j, a, b, order=&#39;K&#39;,</span>
<span class="sd">                            casting=&#39;safe&#39;, buffersize=8192)</span>

<span class="sd">        c = np.empty(...)</span>
<span class="sd">        luf(lambda i,j:i+j, a, b, out=c, order=&#39;K&#39;,</span>
<span class="sd">                            casting=&#39;safe&#39;, buffersize=8192)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">),)</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;buffered&#39;</span><span class="p">,</span><span class="s1">&#39;no_inner_iteration&#39;</span><span class="p">],</span>
            <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">,</span><span class="s1">&#39;nbo_aligned&#39;</span><span class="p">]]</span><span class="o">*</span><span class="n">nargs</span> <span class="o">+</span>
                            <span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">,</span><span class="s1">&#39;no_broadcast&#39;</span><span class="p">]],</span>
            <span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">),</span>
            <span class="n">casting</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;casting&#39;</span><span class="p">,</span><span class="s1">&#39;safe&#39;</span><span class="p">),</span>
            <span class="n">buffersize</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;buffersize&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
        <span class="n">it</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamdaexpr</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Then, by using <code class="docutils literal notranslate"><span class="pre">luf</span></code> instead of straight Python expressions, we
can gain some performance from better cache behavior.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">timeit</span> <span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">138</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">luf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">60.9</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">luf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="python-addition-example">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Python addition example</a><a class="headerlink" href="#python-addition-example" title="Link to this heading">#</a></h4>
<p>The iterator has been mostly written and exposed to Python.  To
see how it behaves, let’s see what we can do with the np.add ufunc.
Even without changing the core of NumPy, we will be able to use
the iterator to make a faster add function.</p>
<p>The Python exposure supplies two iteration interfaces, one which
follows the Python iterator protocol, and another which mirrors the
C-style do-while pattern.  The native Python approach is better
in most cases, but if you need the iterator’s coordinates or
index, use the C-style pattern.</p>
<p>Here is how we might write an <code class="docutils literal notranslate"><span class="pre">iter_add</span></code> function, using the
Python iterator protocol.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">iter_add_py</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">addop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here is the same function, but following the C-style pattern.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">iter_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
        <span class="n">addop</span><span class="p">(</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Some noteworthy points about this function:</p>
<ul class="simple">
<li><p>Cache np.add as a local variable to reduce namespace lookups</p></li>
<li><p>Inputs are readonly, output is writeonly, and will be allocated
automatically if it is None.</p></li>
<li><p>Uses np.add’s out parameter to avoid an extra copy.</p></li>
</ul>
<p>Let’s create some test variables, and time this function as well as the
built-in np.add.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">7.03</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">6.73</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>At a thousand times slower, this is clearly not very good.  One feature
of the iterator, designed to help speed up the inner loops, is the flag
<code class="docutils literal notranslate"><span class="pre">no_inner_iteration</span></code>.  This is the same idea as the old iterator’s
<code class="docutils literal notranslate"><span class="pre">PyArray_IterAllButAxis</span></code>, but slightly smarter.  Let’s modify
<code class="docutils literal notranslate"><span class="pre">iter_add</span></code> to use this feature.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">iter_add_noinner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">addop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">out</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;no_inner_iteration&#39;</span><span class="p">],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">addop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>The performance improves dramatically.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_noinner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">7.1</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>The performance is basically as good as the built-in function!  It
turns out this is because the iterator was able to coalesce the last two
dimensions, resulting in 100 adds of 10000 elements each.  If the
inner loop doesn’t become as large, the performance doesn’t improve
as dramatically.  Let’s use <code class="docutils literal notranslate"><span class="pre">c</span></code> instead of <code class="docutils literal notranslate"><span class="pre">b</span></code> to see how this works.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span><span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_noinner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">76.4</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>It’s still a lot better than seven seconds, but still over ten times worse
than the built-in function.  Here, the inner loop has 100 elements,
and it’s iterating 10000 times.  If we were coding in C, our performance
would already be as good as the built-in performance, but in Python
there is too much overhead.</p>
<p>This leads us to another feature of the iterator, its ability to give
us views of the iterated memory.  The views it gives us are structured
so that processing them in C-order, like the built-in NumPy code does,
gives the same access order as the iterator itself.  Effectively, we
are using the iterator to solve for a good memory access pattern, then
using other NumPy machinery to efficiently execute it.  Let’s
modify <code class="docutils literal notranslate"><span class="pre">iter_add</span></code> once again.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">iter_add_itview</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">out</span><span class="p">],</span> <span class="p">[],</span>
                <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;readonly&#39;</span><span class="p">],[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]])</span>

    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">itviews</span>
    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Now the performance pretty closely matches the built-in function’s.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">6.18</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">6.69</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>Let us now step back to a case similar to the original motivation for the
new iterator.  Here are the same calculations in Fortran memory order instead
Of C memory order.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1000000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">39</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">34.3</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">41</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">31.6</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">44</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">6.58</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">43</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">6.33</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>As you can see, the performance of the built-in function dropped
significantly, but our newly-written add function maintained essentially
the same performance.  As one final test, let’s try several adds chained
together.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">99.5</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">iter_add_itview</span><span class="p">(</span><span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">29.3</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>Also, just to check that it’s doing the same thing,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
   <span class="o">....</span><span class="p">:</span> <span class="n">iter_add_itview</span><span class="p">(</span><span class="n">iter_add_itview</span><span class="p">(</span><span class="n">iter_add_itview</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span>
   <span class="o">....</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
   <span class="o">....</span><span class="p">:</span> <span class="p">)</span>

<span class="n">Out</span><span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="image-compositing-example-revisited">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Image compositing example revisited</a><a class="headerlink" href="#image-compositing-example-revisited" title="Link to this heading">#</a></h4>
<p>For motivation, we had an example that did an ‘over’ composite operation
on two images.  Now let’s see how we can write the function with
the new iterator.</p>
<p>Here is one of the original functions, for reference, and some
random image data.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">rand1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">rand2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">1080</span><span class="o">*</span><span class="mi">1920</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">image1</span> <span class="o">=</span> <span class="n">rand1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="n">image2</span> <span class="o">=</span> <span class="n">rand2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1920</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
  <span class="o">....</span><span class="p">:</span>     <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">im1</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">im2</span>
  <span class="o">....</span><span class="p">:</span>     <span class="n">ret</span> <span class="o">+=</span> <span class="n">im1</span>
  <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="n">ret</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">image2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">1.39</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>Here’s the same function, rewritten to use a new iterator.  Note how
easy it was to add an optional output parameter.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over_it</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">4096</span><span class="p">):</span>
  <span class="o">....</span><span class="p">:</span>     <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">([</span><span class="n">im1</span><span class="p">,</span> <span class="n">im1</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">im2</span><span class="p">,</span> <span class="n">out</span><span class="p">],</span>
  <span class="o">....</span><span class="p">:</span>                     <span class="p">[</span><span class="s1">&#39;buffered&#39;</span><span class="p">,</span><span class="s1">&#39;no_inner_iteration&#39;</span><span class="p">],</span>
  <span class="o">....</span><span class="p">:</span>                     <span class="p">[[</span><span class="s1">&#39;readonly&#39;</span><span class="p">]]</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="p">[[</span><span class="s1">&#39;writeonly&#39;</span><span class="p">,</span><span class="s1">&#39;allocate&#39;</span><span class="p">]],</span>
  <span class="o">....</span><span class="p">:</span>                     <span class="n">op_axes</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span>
  <span class="o">....</span><span class="p">:</span>                     <span class="n">buffersize</span><span class="o">=</span><span class="n">buffersize</span><span class="p">)</span>
  <span class="o">....</span><span class="p">:</span>     <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
  <span class="o">....</span><span class="p">:</span>         <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
  <span class="o">....</span><span class="p">:</span>         <span class="n">it</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="o">....</span><span class="p">:</span>         <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
  <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">197</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>A big speed improvement, over even the best previous attempt using
straight NumPy and a C-order array!  By playing with the buffer size, we can
see how the speed improves until we hit the limits of the CPU cache
in the inner loop.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">1.23</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">699</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">418</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">287</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">225</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">12</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">194</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">13</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">180</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">14</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">14</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">192</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">15</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">280</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">16</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">328</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">17</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">buffersize</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">17</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">345</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>And finally, to double check that it’s working, we can compare the two
functions.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">18</span><span class="p">]:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">composite_over</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">)</span> <span class="o">==</span>
    <span class="o">...</span><span class="p">:</span>        <span class="n">composite_over_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">18</span><span class="p">]:</span> <span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="image-compositing-with-numexpr">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Image compositing with NumExpr</a><a class="headerlink" href="#image-compositing-with-numexpr" title="Link to this heading">#</a></h4>
<p>As a test of the iterator, numexpr has been enhanced to allow use of
the iterator instead of its internal broadcasting code.  First, let’s
implement the composite operation with numexpr.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over_ne</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   <span class="o">....</span><span class="p">:</span>     <span class="n">ima</span> <span class="o">=</span> <span class="n">im1</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
   <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;im1+(1-ima)*im2&quot;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">23</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_ne</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">image2</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">1.25</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
<p>This beats the straight NumPy operation, but isn’t very good.  Switching
to the iterator version of numexpr, we get a big improvement over the
straight Python function using the iterator.  Note that this is on
a dual core machine.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">29</span><span class="p">]:</span> <span class="k">def</span><span class="w"> </span><span class="nf">composite_over_ne_it</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   <span class="o">....</span><span class="p">:</span>     <span class="n">ima</span> <span class="o">=</span> <span class="n">im1</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
   <span class="o">....</span><span class="p">:</span>     <span class="k">return</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate_iter</span><span class="p">(</span><span class="s2">&quot;im1+(1-ima)*im2&quot;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">30</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_ne_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">image2</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">67.2</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">31</span><span class="p">]:</span> <span class="n">ne</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">32</span><span class="p">]:</span> <span class="n">timeit</span> <span class="n">composite_over_ne_it</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span><span class="n">image2</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">91.1</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table-of-contents">Table of contents</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract">Abstract</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation">Motivation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#image-compositing-example">Image compositing example</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#improving-cache-coherency">Improving cache-coherency</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#output-layout-selection-algorithm">Output layout selection algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coalescing-dimensions">Coalescing dimensions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#inner-loop-specialization">Inner loop specialization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation-details">Implementation details</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterator-rewrite">Iterator rewrite</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proposed-iterator-memory-layout">Proposed iterator memory layout</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proposed-iterator-api">Proposed iterator API</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#old-new-iterator-api-conversion">Old -&gt; new iterator API conversion</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#iterator-pointer-type">Iterator pointer type</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#construction-and-destruction">Construction and destruction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#functions-for-iteration">Functions for iteration</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#examples">Examples</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#python-lambda-ufunc-example">Python lambda UFunc example</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#python-addition-example">Python addition example</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#image-compositing-example-revisited">Image compositing example revisited</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#image-compositing-with-numexpr">Image compositing with NumExpr</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2017-2025, NumPy Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>