
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NEP 12 — Missing data functionality in NumPy &#8212; NumPy Enhancement Proposals</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="_static/documentation_options.js?v=7f41d439"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'nep-0012-missing-data';</script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="NEP 21 — Simplified and explicit advanced indexing" href="nep-0021-advanced-indexing.html" />
    <link rel="prev" title="NEP 11 — Deferred UFunc evaluation" href="nep-0011-deferred-ufunc-evaluation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
    <meta name="docbuild:last-update" content="Jan 16, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="content.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/numpylogo.svg" class="logo__image only-light" alt="NumPy Enhancement Proposals - Home"/>
    <img src="_static/numpylogo.svg" class="logo__image only-dark pst-js-only" alt="NumPy Enhancement Proposals - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="scope.html">The Scope of NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Current roadmap</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">Wish list</a></li>
</ul>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="meta.html">Meta-NEPs (NEPs about NEPs or active Processes)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0000.html">NEP 0 — Purpose and process</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0023-backwards-compatibility.html">NEP 23 — Backwards compatibility and deprecation policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0036-fair-play.html">NEP 36 — Fair play</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0045-c_style_guide.html">NEP 45 — C style guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0046-sponsorship-guidelines.html">NEP 46 — NumPy sponsorship guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0048-spending-project-funds.html">NEP 48 — Spending NumPy project funds</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-template.html">NEP X — Template and instructions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="provisional.html">Provisional NEPs (provisionally accepted; interface may change)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="accepted.html">Accepted NEPs (implementation in progress)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0041-improved-dtype-support.html">NEP 41 — First step towards a new datatype system</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0042-new-dtypes.html">NEP 42 — New and extensible DTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0044-restructuring-numpy-docs.html">NEP 44 — Restructuring the NumPy documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0051-scalar-representation.html">NEP 51 — Changing the representation of NumPy scalars</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="open.html">Open NEPs (under consideration)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0043-extensible-ufuncs.html">NEP 43 — Enhancing the extensibility of UFuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0053-c-abi-evolution.html">NEP 53 — Evolving the NumPy C-API for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0054-simd-cpp-highway.html">NEP 54 — SIMD infrastructure evolution: adopting Google Highway when moving to C++?</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="finished.html">Finished NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0001-npy-format.html">NEP 1 — A simple file format for NumPy arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0005-generalized-ufuncs.html">NEP 5 — Generalized universal functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0007-datetime-proposal.html">NEP 7 — A proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0010-new-iterator-ufunc.html">NEP 10 — Optimizing iterator/UFunc performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0013-ufunc-overrides.html">NEP 13 — A mechanism for overriding Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0014-dropping-python2.7-proposal.html">NEP 14 — Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0015-merge-multiarray-umath.html">NEP 15 — Merging multiarray and umath</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0018-array-function-protocol.html">NEP 18 — A dispatch mechanism for NumPy's high level array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0019-rng-policy.html">NEP 19 — Random number generator policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0020-gufunc-signature-enhancement.html">NEP 20 — Expansion of generalized universal function signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0022-ndarray-duck-typing-overview.html">NEP 22 — Duck typing for NumPy arrays – high level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0027-zero-rank-arrarys.html">NEP 27 — Zero rank arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0028-website-redesign.html">NEP 28 — numpy.org website redesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0029-deprecation_policy.html">NEP 29 — Recommend Python and NumPy version support as a community policy standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0032-remove-financial-functions.html">NEP 32 — Remove the financial functions from NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0034-infer-dtype-is-object.html">NEP 34 — Disallow inferring ``dtype=object`` from sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0035-array-creation-dispatch-with-array-function.html">NEP 35 — Array creation dispatching with __array_function__</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0038-SIMD-optimizations.html">NEP 38 — Using SIMD optimization instructions for performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0040-legacy-datatype-impl.html">NEP 40 — Legacy datatype implementation in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0049.html">NEP 49 — Data allocation strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0050-scalar-promotion.html">NEP 50 — Promotion rules for Python scalars</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0052-python-api-cleanup.html">NEP 52 — Python API cleanup for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0055-string_dtype.html">NEP 55 — Add a UTF-8 variable-width string DType to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0056-array-api-main-namespace.html">NEP 56 — Array API standard support in NumPy's main namespace</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="deferred.html">Deferred and Superseded NEPs</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nep-0002-warnfix.html">NEP 2 — A proposal to build numpy without warning with a big set of warning flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0003-math_config_clean.html">NEP 3 — Cleaning the math configuration of numpy.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0004-datetime-proposal3.html">NEP 4 — A (third) proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0006-newbugtracker.html">NEP 6 — Replacing Trac with a different bug tracker</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0008-groupby_additions.html">NEP 8 — A proposal for adding groupby functionality to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0009-structured_array_extensions.html">NEP 9 — Structured array extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0011-deferred-ufunc-evaluation.html">NEP 11 — Deferred UFunc evaluation</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">NEP 12 — Missing data functionality in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0021-advanced-indexing.html">NEP 21 — Simplified and explicit advanced indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0024-missing-data-2.html">NEP 24 — Missing data functionality - alternative 1 to NEP 12</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0025-missing-data-3.html">NEP 25 — NA support via special dtypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0026-missing-data-summary.html">NEP 26 — Summary of missing data NEPs and discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0030-duck-array-protocol.html">NEP 30 — Duck typing for NumPy arrays - implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0031-uarray.html">NEP 31 — Context-local and global overrides of the NumPy API</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0037-array-module.html">NEP 37 — A dispatch protocol for NumPy-like modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0047-array-api-standard.html">NEP 47 — Adopting the array API standard</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="rejected.html">Rejected and Withdrawn NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0016-abstract-array.html">NEP 16 — An abstract base class for identifying "duck arrays"</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0017-split-out-maskedarray.html">NEP 17 — Split out masked arrays</a></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="content.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Roadmap &amp; NumPy enhancement proposals</a></li>
    
    
    <li class="breadcrumb-item"><a href="deferred.html" class="nav-link">Deferred and Superseded NEPs</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">NEP 12 — Missing data functionality in NumPy</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="nep-12-missing-data-functionality-in-numpy">
<span id="nep12"></span><h1><a class="toc-backref" href="#id1" role="doc-backlink">NEP 12 — Missing data functionality in NumPy</a><a class="headerlink" href="#nep-12-missing-data-functionality-in-numpy" title="Link to this heading">#</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mark Wiebe &lt;<a class="reference external" href="mailto:mwwiebe&#37;&#52;&#48;gmail&#46;com">mwwiebe<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Copyright<span class="colon">:</span></dt>
<dd class="field-even"><p>Copyright 2011 by Enthought, Inc</p>
</dd>
<dt class="field-odd">License<span class="colon">:</span></dt>
<dd class="field-odd"><p>CC By-SA 3.0 (<a class="reference external" href="https://creativecommons.org/licenses/by-sa/3.0/">https://creativecommons.org/licenses/by-sa/3.0/</a>)</p>
</dd>
<dt class="field-even">Date<span class="colon">:</span></dt>
<dd class="field-even"><p>2011-06-23</p>
</dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><p>Deferred</p>
</dd>
</dl>
<section id="table-of-contents">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Table of contents</a><a class="headerlink" href="#table-of-contents" title="Link to this heading">#</a></h2>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#nep-12-missing-data-functionality-in-numpy" id="id1">NEP 12 — Missing data functionality in NumPy</a></p>
<ul>
<li><p><a class="reference internal" href="#table-of-contents" id="id2">Table of contents</a></p></li>
<li><p><a class="reference internal" href="#abstract" id="id3">Abstract</a></p></li>
<li><p><a class="reference internal" href="#definition-of-missing-data" id="id4">Definition of missing data</a></p>
<ul>
<li><p><a class="reference internal" href="#unknown-yet-existing-data-na" id="id5">Unknown yet existing data (NA)</a></p></li>
<li><p><a class="reference internal" href="#data-that-doesn-t-exist-or-is-being-skipped-ignore" id="id6">Data that doesn’t exist or is being skipped (IGNORE)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation-techniques-for-missing-values" id="id7">Implementation techniques for missing values</a></p>
<ul>
<li><p><a class="reference internal" href="#bit-patterns-signalling-missing-values-bitpattern" id="id8">Bit patterns signalling missing values (bitpattern)</a></p></li>
<li><p><a class="reference internal" href="#boolean-masks-signalling-missing-values-mask" id="id9">Boolean masks signalling missing values (mask)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#glossary-of-terms" id="id10">Glossary of terms</a></p></li>
<li><p><a class="reference internal" href="#missing-values-as-seen-in-python" id="id11">Missing values as seen in Python</a></p>
<ul>
<li><p><a class="reference internal" href="#working-with-missing-values" id="id12">Working with missing values</a></p></li>
<li><p><a class="reference internal" href="#accessing-a-boolean-mask" id="id13">Accessing a boolean mask</a></p></li>
<li><p><a class="reference internal" href="#creating-na-masked-arrays" id="id14">Creating NA-masked arrays</a></p></li>
<li><p><a class="reference internal" href="#na-masks-when-constructing-from-lists" id="id15">Na-masks when constructing from lists</a></p></li>
<li><p><a class="reference internal" href="#mask-implementation-details" id="id16">Mask implementation details</a></p></li>
<li><p><a class="reference internal" href="#new-ndarray-methods" id="id17">New ndarray methods</a></p></li>
<li><p><a class="reference internal" href="#element-wise-ufuncs-with-missing-values" id="id18">Element-wise ufuncs with missing values</a></p></li>
<li><p><a class="reference internal" href="#reduction-ufuncs-with-missing-values" id="id19">Reduction ufuncs with missing values</a></p></li>
<li><p><a class="reference internal" href="#parameterized-na-data-types" id="id20">Parameterized NA data types</a></p></li>
<li><p><a class="reference internal" href="#future-expansion-to-multi-na-payloads" id="id21">Future expansion to multi-NA payloads</a></p></li>
<li><p><a class="reference internal" href="#differences-with-numpy-ma" id="id22">Differences with numpy.ma</a></p></li>
<li><p><a class="reference internal" href="#boolean-indexing" id="id23">Boolean indexing</a></p></li>
<li><p><a class="reference internal" href="#pep-3118" id="id24">PEP 3118</a></p></li>
<li><p><a class="reference internal" href="#cython" id="id25">Cython</a></p></li>
<li><p><a class="reference internal" href="#hard-masks" id="id26">Hard masks</a></p></li>
<li><p><a class="reference internal" href="#shared-masks" id="id27">Shared masks</a></p></li>
<li><p><a class="reference internal" href="#interaction-with-pre-existing-c-api-usage" id="id28">Interaction with pre-existing C API usage</a></p>
<ul>
<li><p><a class="reference internal" href="#numpy-documentation-how-to-extend-numpy" id="id29">NumPy documentation - how to extend NumPy</a></p></li>
<li><p><a class="reference internal" href="#tutorial-from-cython-website" id="id30">Tutorial from Cython website</a></p></li>
<li><p><a class="reference internal" href="#numerical-python-jpl-website" id="id31">Numerical Python - JPL website</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-implementation-details" id="id32">C implementation details</a></p>
<ul>
<li><p><a class="reference internal" href="#mask-binary-format" id="id33">Mask binary format</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-iterator-api-changes-iteration-with-masks" id="id34">C iterator API changes: iteration with masks</a></p>
<ul>
<li><p><a class="reference internal" href="#iterator-mask-features" id="id35">Iterator mask features</a></p></li>
<li><p><a class="reference internal" href="#iterator-na-array-features" id="id36">Iterator NA-array features</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#rejected-alternative" id="id37">Rejected alternative</a></p>
<ul>
<li><p><a class="reference internal" href="#parameterized-data-type-which-adds-additional-memory-for-the-na-flag" id="id38">Parameterized data type which adds additional memory for the NA flag</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#acknowledgments" id="id39">Acknowledgments</a></p></li>
</ul>
</li>
</ul>
</nav>
</section>
<section id="abstract">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Abstract</a><a class="headerlink" href="#abstract" title="Link to this heading">#</a></h2>
<p>Users interested in dealing with missing data within NumPy are generally
pointed to the masked array subclass of the ndarray, known
as ‘numpy.ma’. This class has a number of users who depend strongly
on its capabilities, but people who are accustomed to the deep integration
of the missing data placeholder “NA” in the R project and others who
find the programming interface challenging or inconsistent tend not
to use it.</p>
<p>This NEP proposes to integrate a mask-based missing data solution
into NumPy, with an additional bitpattern-based missing data solution
that can be implemented  concurrently or later integrating seamlessly
with the mask-based solution.</p>
<p>The mask-based solution and the bitpattern-based solutions in this
proposal offer the exact same missing value abstraction, with several
differences in performance, memory overhead, and flexibility.</p>
<p>The mask-based solution is more flexible, supporting all behaviors of the
bitpattern-based solution, but leaving the hidden values untouched
whenever an element is masked.</p>
<p>The bitpattern-based solution requires less memory, is bit-level
compatible with the 64-bit floating point representation used in R, but
does not preserve the hidden values and in fact requires stealing at
least one bit pattern from the underlying dtype to represent the missing
value NA.</p>
<p>Both solutions are generic in the sense that they can be used with
custom data types very easily, with no effort in the case of the masked
solution, and with the requirement that a bit pattern to sacrifice be
chosen in the case of the bitpattern solution.</p>
</section>
<section id="definition-of-missing-data">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Definition of missing data</a><a class="headerlink" href="#definition-of-missing-data" title="Link to this heading">#</a></h2>
<p>In order to be able to develop an intuition about what computation
will be done by various NumPy functions, a consistent conceptual
model of what a missing element means must be applied.
Ferreting out the behaviors people need or want when they are working
with “missing data” seems to be tricky, but I believe that it boils
down to two different ideas, each of which is internally self-consistent.</p>
<p>One of them, the “unknown yet existing data” interpretation, can be applied
rigorously to all computations, while the other makes sense for
some statistical operations like standard deviation but not for
linear algebra operations like matrix product.
Thus, making “unknown yet existing data” be the default interpretation
is superior, providing a consistent model across all computations,
and for those operations where the other interpretation makes sense,
an optional parameter “skipna=” can be added.</p>
<p>For people who want the other interpretation to be default, a mechanism
proposed elsewhere for customizing subclass ufunc behavior with a
_numpy_ufunc_ member function would allow a subclass with a different
default to be created.</p>
<section id="unknown-yet-existing-data-na">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Unknown yet existing data (NA)</a><a class="headerlink" href="#unknown-yet-existing-data-na" title="Link to this heading">#</a></h3>
<p>This is the approach taken in the R project, defining a missing element
as something which does have a valid value which isn’t known, or is
NA (not available). This proposal adopts this behavior as the
default for all operations involving missing values.</p>
<p>In this interpretation, nearly any computation with a missing input produces
a missing output. For example, ‘sum(a)’ would produce a missing value
if ‘a’ contained just one missing element. When the output value does
not depend on one of the inputs, it is reasonable to output a value
that is not NA, such as logical_and(NA, False) == False.</p>
<p>Some more complex arithmetic operations, such as matrix products, are
well defined with this interpretation, and the result should be
the same as if the missing values were NaNs. Actually implementing
such things to the theoretical limit is probably not worth it,
and in many cases either raising an exception or returning all
missing values may be preferred to doing precise calculations.</p>
</section>
<section id="data-that-doesn-t-exist-or-is-being-skipped-ignore">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Data that doesn’t exist or is being skipped (IGNORE)</a><a class="headerlink" href="#data-that-doesn-t-exist-or-is-being-skipped-ignore" title="Link to this heading">#</a></h3>
<p>Another useful interpretation is that the missing elements should be
treated as if they didn’t exist in the array, and the operation should
do its best to interpret what that means according to the data
that’s left. In this case, ‘mean(a)’ would compute the mean of just
the values that are available, adjusting both the sum and count it
uses based on which values are missing. To be consistent, the mean of
an array of all missing values must produce the same result as the
mean of a zero-sized array without missing value support.</p>
<p>This kind of data can arise when conforming sparsely sampled data
into a regular sampling pattern, and is a useful interpretation to
use when attempting to get best-guess answers for many statistical queries.</p>
<p>In R, many functions take a parameter “na.rm=T” which means to treat
the data as if the NA values are not part of the data set. This proposal
defines a standard parameter “skipna=True” for this same purpose.</p>
</section>
</section>
<section id="implementation-techniques-for-missing-values">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Implementation techniques for missing values</a><a class="headerlink" href="#implementation-techniques-for-missing-values" title="Link to this heading">#</a></h2>
<p>In addition to there being two different interpretations of missing values,
there are two different commonly used implementation techniques for
missing values. While there are some differing default behaviors between
existing implementations of the techniques, I believe that the design
choices made in a new implementation must be made based on their merits,
not by rote copying of previous designs.</p>
<p>Both masks and bitpatterns have different strong and weak points,
depending on the application context. This NEP thus proposes to implement
both. To enable the writing of generic “missing value” code which does
not have to worry about whether the arrays it is using have taken one
or the other approach, the missing value semantics will be identical
for the two implementations.</p>
<section id="bit-patterns-signalling-missing-values-bitpattern">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Bit patterns signalling missing values (bitpattern)</a><a class="headerlink" href="#bit-patterns-signalling-missing-values-bitpattern" title="Link to this heading">#</a></h3>
<p>One or more patterns of bits, for example a NaN with
a particular payload, are chosen to represent the missing value
placeholder NA.</p>
<p>A consequence of this approach is that assigning NA changes the bits
holding the value, so that value is gone.</p>
<p>Additionally, for some types such as integers, a good and proper value
must be sacrificed to enable this functionality.</p>
</section>
<section id="boolean-masks-signalling-missing-values-mask">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Boolean masks signalling missing values (mask)</a><a class="headerlink" href="#boolean-masks-signalling-missing-values-mask" title="Link to this heading">#</a></h3>
<p>A mask is a parallel array of booleans, either one byte per element or
one bit per element, allocated alongside the existing array data. In this
NEP, the convention is chosen that True means the element is valid
(unmasked), and False means the element is NA.</p>
<p>By taking care when writing any C algorithm that works with values
and masks together, it is possible to have the memory for a value
that is masked never be written to. This feature allows multiple
simultaneous views of the same data with different choices of what
is missing, a feature requested by many people on the mailing list.</p>
<p>This approach places no limitations on the values of the underlying
data type, it may take on any binary pattern without affecting the
NA behavior.</p>
</section>
</section>
<section id="glossary-of-terms">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Glossary of terms</a><a class="headerlink" href="#glossary-of-terms" title="Link to this heading">#</a></h2>
<p>Because the above discussions of the different concepts and their
relationships are tricky to understand, here are more succinct
definitions of the terms used in this NEP.</p>
<dl class="simple">
<dt>NA (Not Available/Propagate)</dt><dd><p>A placeholder for a value which is unknown to computations. That
value may be temporarily hidden with a mask, may have been lost
due to hard drive corruption, or gone for any number of reasons.
For sums and products this means to produce NA if any of the inputs
are NA. This is the same as NA in the R project.</p>
</dd>
<dt>IGNORE (Ignore/Skip)</dt><dd><p>A placeholder which should be treated by computations as if no value does
or could exist there. For sums, this means act as if the value
were zero, and for products, this means act as if the value were one.
It’s as if the array were compressed in some fashion to not include
that element.</p>
</dd>
<dt>bitpattern</dt><dd><p>A technique for implementing either NA or IGNORE, where a particular
set of bit patterns are chosen from all the possible bit patterns of the
value’s data type to signal that the element is NA or IGNORE.</p>
</dd>
<dt>mask</dt><dd><p>A technique for implementing either NA or IGNORE, where a
boolean or enum array parallel to the data array is used to signal
which elements are NA or IGNORE.</p>
</dd>
<dt>numpy.ma</dt><dd><p>The existing implementation of a particular form of masked arrays,
which is part of the NumPy codebase.</p>
</dd>
<dt>Python API</dt><dd><p>All the interface mechanisms that are exposed to Python code
for using missing values in NumPy. This API is designed to be
Pythonic and fit into the way NumPy works as much as possible.</p>
</dd>
<dt>C API</dt><dd><p>All the implementation mechanisms exposed for CPython extensions
written in C that want to support NumPy missing value support.
This API is designed to be as natural as possible in C, and
is usually prioritizes flexibility and high performance.</p>
</dd>
</dl>
</section>
<section id="missing-values-as-seen-in-python">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Missing values as seen in Python</a><a class="headerlink" href="#missing-values-as-seen-in-python" title="Link to this heading">#</a></h2>
<section id="working-with-missing-values">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Working with missing values</a><a class="headerlink" href="#working-with-missing-values" title="Link to this heading">#</a></h3>
<p>NumPy will gain a global singleton called numpy.NA, similar to None,
but with semantics reflecting its status as a missing value. In particular,
trying to treat it as a boolean will raise an exception, and comparisons
with it will produce numpy.NA instead of True or False. These basics are
adopted from the behavior of the NA value in the R project. To dig
deeper into the ideas, <a class="reference external" href="https://en.wikipedia.org/wiki/Ternary_logic#Kleene_logic">https://en.wikipedia.org/wiki/Ternary_logic#Kleene_logic</a>
provides a starting point.</p>
<p>For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1., 2., NA, 7.], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;NA&#39;</span><span class="p">)</span>
<span class="go">array([1., 2., NA, 7.], dtype=&#39;NA[&lt;f8]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;NA[f4]&#39;</span><span class="p">)</span>
<span class="go">array([1., 2., NA, 7.], dtype=&#39;NA[&lt;f4]&#39;)</span>
</pre></div>
</div>
<p>produce arrays with values [1.0, 2.0, &lt;inaccessible&gt;, 7.0] /
mask [Exposed, Exposed, Hidden, Exposed], and
values [1.0, 2.0, &lt;NA bitpattern&gt;, 7.0] for the masked and
NA dtype versions respectively.</p>
<p>The np.NA singleton may accept a dtype= keyword parameter, indicating
that it should be treated as an NA of a particular data type. This is also
a mechanism for preserving the dtype in a NumPy scalar-like fashion.
Here’s what this looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">NA(dtype=&#39;&lt;f8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;NA[f8]&#39;</span><span class="p">))</span>
<span class="go">NA(dtype=&#39;NA[&lt;f8]&#39;)</span>
</pre></div>
</div>
<p>Assigning a value to an array always causes that element to not be NA,
transparently unmasking it if necessary. Assigning numpy.NA to the array
masks that element or assigns the NA bitpattern for the particular dtype.
In the mask-based implementation, the storage behind a missing value may never
be accessed in any way, other than to unmask it by assigning its value.</p>
<p>To test if a value is missing, the function “np.isna(arr[0])” will
be provided. One of the key reasons for the NumPy scalars is to allow
their values into dictionaries.</p>
<p>All operations which write to masked arrays will not affect the value
unless they also unmask that value. This allows the storage behind
masked elements to still be relied on if they are still accessible
from another view which doesn’t have them masked. For example, the
following was run on the missingdata work-in-progress branch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([1, 2], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([NA, 2], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The underlying number 1 value in &#39;a[0]&#39; was untouched</span>
</pre></div>
</div>
<p>Copying values between the mask-based implementation and the
bitpattern implementation will transparently do the correct thing,
turning the bitpattern into a masked value, or a masked value
into the bitpattern where appropriate. The one exception is
if a valid value in a masked array happens to have the NA bitpattern,
copying this value to the NA form of the dtype will cause it to
become NA as well.</p>
<p>When operations are done between arrays with NA dtypes and masked arrays,
the result will be masked arrays. This is because in some cases the
NA dtypes cannot represent all the values in the masked array, so
going to masked arrays is the only way to preserve all aspects of the data.</p>
<p>If np.NA or masked values are copied to an array without support for
missing values enabled, an exception will be raised. Adding a mask to
the target array would be problematic, because then having a mask
would be a “viral” property consuming extra memory and reducing
performance in unexpected ways.</p>
<p>By default, the string “NA” will be used to represent missing values
in str and repr outputs. A global configuration will allow
this to be changed, exactly extending the way nan and inf are treated.
The following works in the current draft implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, NA, 4, 5], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">nastr</span><span class="o">=</span><span class="s1">&#39;blah&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, blah, 4, 5], maskna=True)</span>
</pre></div>
</div>
<p>For floating point numbers, Inf and NaN are separate concepts from
missing values. If a division by zero occurs in an array with default
missing value support, an unmasked Inf or NaN will be produced. To
mask those values, a further ‘a[np.logical_not(a.isfinite(a))] = np.NA’
can achieve that. For the bitpattern approach, the parameterized
dtype(‘NA[f8,InfNan]’) described in a later section can be used to get
these semantics without the extra manipulation.</p>
<p>A manual loop through a masked array like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0.,  1.,  2., NA,  4.], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">__main__:2: RuntimeWarning: divide by zero encountered in log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([       -inf,  0.        ,  0.69314718, NA,  1.38629436], maskna=True)</span>
</pre></div>
</div>
<p>works even with masked values, because ‘a[i]’ returns an NA object
with a data type associated, that can be treated properly by the ufuncs.</p>
</section>
<section id="accessing-a-boolean-mask">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Accessing a boolean mask</a><a class="headerlink" href="#accessing-a-boolean-mask" title="Link to this heading">#</a></h3>
<p>The mask used to implement missing data in the masked approach is not
accessible from Python directly. This is partially due to differing
opinions on whether True in the mask should mean “missing” or “not missing”
Additionally, exposing the mask directly would preclude a potential
space optimization, where a bit-level instead of a byte-level mask
is used to get a factor of eight memory usage improvement.</p>
<p>To access a mask directly, there are two functions provided. They
work equivalently for both arrays with masks and NA bit
patterns, so they are specified in terms of NA and available values
instead of masked and unmasked values. The functions are
‘np.isna’ and ‘np.isavail’, which test for NA or available values
respectively.</p>
</section>
<section id="creating-na-masked-arrays">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Creating NA-masked arrays</a><a class="headerlink" href="#creating-na-masked-arrays" title="Link to this heading">#</a></h3>
<p>The usual way to create an array with an NA mask is to pass the keyword
parameter maskna=True to one of the constructors. Most functions that
create a new array take this parameter, and produce an NA-masked
array with all its elements exposed when the parameter is set to True.</p>
<p>There are also two flags which indicate and control the nature of the mask
used in masked arrays. These flags can be used to add a mask, or ensure
the mask isn’t a view into another array’s mask.</p>
<p>First is ‘arr.flags.maskna’, which is True for all masked arrays and
may be set to True to add a mask to an array which does not have one.</p>
<p>Second is ‘arr.flags.ownmaskna’, which is True if the array owns the
memory to the mask, and False if the array has no mask, or has a view
into the mask of another array. If this is set to True in a masked
array, the array will create a copy of the mask so that further modifications
to the mask will not affect the original mask from which the view was taken.</p>
</section>
<section id="na-masks-when-constructing-from-lists">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Na-masks when constructing from lists</a><a class="headerlink" href="#na-masks-when-constructing-from-lists" title="Link to this heading">#</a></h3>
<p>The initial design of NA-mask construction was to make all construction
fully explicit. This turns out to be unwieldy when working interactively
with NA-masked arrays, and having an object array be created instead of
an NA-masked array can be very surprising.</p>
<p>Because of this, the design has been changed to enable an NA-mask whenever
creating an array from lists which have an NA object in them. There could
be some debate of whether one should create NA-masks or NA-bitpatterns
by default, but due to the time constraints it was only feasible to tackle
NA-masks, and extending the NA-mask support more fully throughout NumPy seems
much more reasonable than starting another system and ending up with two
incomplete systems.</p>
</section>
<section id="mask-implementation-details">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Mask implementation details</a><a class="headerlink" href="#mask-implementation-details" title="Link to this heading">#</a></h3>
<p>The memory ordering of the mask will always match the ordering of
the array it is associated with. A Fortran-style array will have a
Fortran-style mask, etc.</p>
<p>When a view of an array with a mask is taken, the view will have
a mask which is also a view of the mask in the original
array. This means unmasking values in views will also unmask them
in the original array, and if a mask is added to an array, it will
not be possible to ever remove that mask except to create a new array
copying the data but not the mask.</p>
<p>It is still possible to temporarily treat an array with a mask without
giving it one, by first creating a view of the array and then adding a
mask to that view. A data set can be viewed with multiple different
masks simultaneously, by creating multiple views, and giving each view
a mask.</p>
</section>
<section id="new-ndarray-methods">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">New ndarray methods</a><a class="headerlink" href="#new-ndarray-methods" title="Link to this heading">#</a></h3>
<p>New functions added to the numpy namespace are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="p">[</span><span class="n">IMPLEMENTED</span><span class="p">]</span>
    <span class="n">Returns</span> <span class="n">a</span> <span class="n">boolean</span> <span class="n">array</span> <span class="k">with</span> <span class="kc">True</span> <span class="n">wherever</span> <span class="n">the</span> <span class="n">array</span> <span class="ow">is</span> <span class="n">masked</span>
    <span class="ow">or</span> <span class="n">matches</span> <span class="n">the</span> <span class="n">NA</span> <span class="n">bitpattern</span><span class="p">,</span> <span class="ow">and</span> <span class="kc">False</span> <span class="n">elsewhere</span>

<span class="n">np</span><span class="o">.</span><span class="n">isavail</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">Returns</span> <span class="n">a</span> <span class="n">boolean</span> <span class="n">array</span> <span class="k">with</span> <span class="kc">False</span> <span class="n">wherever</span> <span class="n">the</span> <span class="n">array</span> <span class="ow">is</span> <span class="n">masked</span>
    <span class="ow">or</span> <span class="n">matches</span> <span class="n">the</span> <span class="n">NA</span> <span class="n">bitpattern</span><span class="p">,</span> <span class="ow">and</span> <span class="kc">True</span> <span class="n">elsewhere</span>
</pre></div>
</div>
<p>New functions added to the ndarray are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">replacena</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">)</span>
    <span class="n">Modification</span> <span class="n">to</span> <span class="n">the</span> <span class="n">copy</span> <span class="n">function</span> <span class="n">which</span> <span class="n">replaces</span> <span class="n">NA</span> <span class="n">values</span><span class="p">,</span>
    <span class="n">either</span> <span class="n">masked</span> <span class="ow">or</span> <span class="k">with</span> <span class="n">the</span> <span class="n">NA</span> <span class="n">bitpattern</span><span class="p">,</span> <span class="k">with</span> <span class="n">the</span> <span class="s1">&#39;replacena=&#39;</span>
    <span class="n">parameter</span> <span class="n">supplied</span><span class="o">.</span> <span class="n">When</span> <span class="s1">&#39;replacena&#39;</span> <span class="n">isn</span><span class="s1">&#39;t NA, the copied</span>
    <span class="n">array</span> <span class="ow">is</span> <span class="n">unmasked</span> <span class="ow">and</span> <span class="n">has</span> <span class="n">the</span> <span class="s1">&#39;NA&#39;</span> <span class="n">part</span> <span class="n">stripped</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span>
    <span class="n">parameterized</span> <span class="n">dtype</span> <span class="p">(</span><span class="s1">&#39;NA[f8]&#39;</span> <span class="n">becomes</span> <span class="n">just</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span><span class="o">.</span>

    <span class="n">The</span> <span class="n">default</span> <span class="k">for</span> <span class="n">replacena</span> <span class="ow">is</span> <span class="n">chosen</span> <span class="n">to</span> <span class="n">be</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span> <span class="n">instead</span> <span class="n">of</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">because</span> <span class="n">it</span> <span class="n">may</span> <span class="n">be</span> <span class="n">desirable</span> <span class="n">to</span> <span class="n">replace</span> <span class="n">NA</span> <span class="k">with</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">an</span>
    <span class="n">NA</span><span class="o">-</span><span class="n">masked</span> <span class="nb">object</span> <span class="n">array</span><span class="o">.</span>

    <span class="n">For</span> <span class="n">future</span> <span class="n">multi</span><span class="o">-</span><span class="n">NA</span> <span class="n">support</span><span class="p">,</span> <span class="s1">&#39;replacena&#39;</span> <span class="n">could</span> <span class="n">accept</span> <span class="n">a</span> <span class="n">dictionary</span>
    <span class="n">mapping</span> <span class="n">the</span> <span class="n">NA</span> <span class="n">payload</span> <span class="n">to</span> <span class="n">the</span> <span class="n">value</span> <span class="n">to</span> <span class="n">substitute</span> <span class="k">for</span> <span class="n">that</span>
    <span class="n">particular</span> <span class="n">NA</span><span class="o">.</span> <span class="n">NAs</span> <span class="k">with</span> <span class="n">payloads</span> <span class="ow">not</span> <span class="n">appearing</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">dictionary</span>
    <span class="n">would</span> <span class="n">remain</span> <span class="k">as</span> <span class="n">NA</span> <span class="n">unless</span> <span class="n">a</span> <span class="s1">&#39;default&#39;</span> <span class="n">key</span> <span class="n">was</span> <span class="n">also</span> <span class="n">supplied</span><span class="o">.</span>

    <span class="n">Both</span> <span class="n">the</span> <span class="n">parameter</span> <span class="n">to</span> <span class="n">replacena</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">dictionaries</span>
    <span class="n">can</span> <span class="n">be</span> <span class="n">either</span> <span class="n">scalars</span> <span class="ow">or</span> <span class="n">arrays</span> <span class="n">which</span> <span class="n">get</span> <span class="n">broadcast</span> <span class="n">onto</span> <span class="s1">&#39;arr&#39;</span><span class="o">.</span>

<span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">[</span><span class="n">IMPLEMENTED</span><span class="p">]</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">shortcut</span> <span class="k">for</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">maskna</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ownmaskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">[</span><span class="n">IMPLEMENTED</span><span class="p">]</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">shortcut</span> <span class="k">for</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">maskna</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">ownmaskna</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</section>
<section id="element-wise-ufuncs-with-missing-values">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Element-wise ufuncs with missing values</a><a class="headerlink" href="#element-wise-ufuncs-with-missing-values" title="Link to this heading">#</a></h3>
<p>As part of the implementation, ufuncs and other operations will
have to be extended to support masked computation. Because this
is a useful feature in general, even outside the context of
a masked array, in addition to working with masked arrays ufuncs
will take an optional ‘where=’ parameter which allows the use
of boolean arrays to choose where a computation should be done.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>
</pre></div>
</div>
<p>A benefit of having this ‘where=’ parameter is that it provides a way
to temporarily treat an object with a mask without ever creating a
masked array object. In the example above, this would only do the
add for the array elements with True in the ‘where’ clause, and neither
‘a’ nor ‘b’ need to be masked arrays.</p>
<p>If the ‘out’ parameter isn’t specified, use of the ‘where=’ parameter
will produce an array with a mask as the result, with missing values
for everywhere the ‘where’ clause had the value False.</p>
<p>For boolean operations, the R project special cases logical_and and
logical_or so that logical_and(NA, False) is False, and
logical_or(NA, True) is True. On the other hand, 0 * NA isn’t 0, but
here the NA could represent Inf or NaN, in which case 0 * the backing
value wouldn’t be 0 anyway.</p>
<p>For NumPy element-wise ufuncs, the design won’t support this ability
for the mask of the output to depend simultaneously on the mask and
the value of the inputs. The NumPy 1.6 nditer, however, makes it
fairly easy to write standalone functions which look and feel just
like ufuncs, but deviate from their behavior. The functions logical_and
and logical_or can be moved into standalone function objects which are
backwards compatible with the current ufuncs.</p>
</section>
<section id="reduction-ufuncs-with-missing-values">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Reduction ufuncs with missing values</a><a class="headerlink" href="#reduction-ufuncs-with-missing-values" title="Link to this heading">#</a></h3>
<p>Reduction operations like ‘sum’, ‘prod’, ‘min’, and ‘max’ will operate
consistently with the idea that a masked value exists, but its value
is unknown.</p>
<p>An optional parameter ‘skipna=’ will be added to those functions
which can interpret it appropriately to do the operation as if just
the unmasked values existed.</p>
<p>With ‘skipna=True’, when all the input values are masked,
‘sum’ and ‘prod’ will produce the additive and multiplicative identities
respectively, while ‘min’ and ‘max’ will produce masked values.
Statistics operations which require a count, like ‘mean’ and ‘std’
will also use the unmasked value counts for their calculations if
‘skipna=True’, and produce masked values when all the inputs are masked.</p>
<p>Some examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mf">7.</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array(NA, dtype=&#39;&lt;f8&#39;, maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">11.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">NA(dtype=&#39;&lt;f8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.6666666666666665</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">,</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array(NA, dtype=&#39;&lt;f8&#39;, maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">NA(dtype=&#39;&lt;f8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">/home/mwiebe/virtualenvs/dev/lib/python2.7/site-packages/numpy/core/fromnumeric.py:2374: RuntimeWarning: invalid value encountered in double_scalars</span>
<span class="go">  return mean(axis, dtype, out)</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>The functions ‘np.any’ and ‘np.all’ require some special consideration,
just as logical_and and logical_or do. Maybe the best way to describe
their behavior is through a series of examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">NA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">NA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Since ‘np.any’ is the reduction for ‘np.logical_or’, and ‘np.all’
is the reduction for ‘np.logical_and’, it makes sense for them to
have a ‘skipna=’ parameter like the other similar reduction functions.</p>
</section>
<section id="parameterized-na-data-types">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Parameterized NA data types</a><a class="headerlink" href="#parameterized-na-data-types" title="Link to this heading">#</a></h3>
<p>A masked array isn’t the only way to deal with missing data, and
some systems deal with the problem by defining a special “NA” value,
for data which is missing. This is distinct from NaN floating point
values, which are the result of bad floating point calculation values,
but many people use NaNs for this purpose.</p>
<p>In the case of IEEE floating point values, it is possible to use a
particular NaN value, of which there are many, for “NA”, distinct
from NaN. For signed integers, a reasonable approach would be to use
the minimum storable value, which doesn’t have a corresponding positive
value. For unsigned integers, the maximum storage value seems most
reasonable.</p>
<p>With the goal of providing a general mechanism, a parameterized type
mechanism for this is much more attractive than creating separate
nafloat32, nafloat64, naint64, nauint64, etc dtypes. If this is viewed
as an alternative way of treating the mask except without value preservation,
this parameterized type can work together with the mask in a special
way to produce a value + mask combination on the fly, and use the
exact same computational infrastructure as the masked array system.
This allows one to avoid the need to write special case code for each
ufunc and for each na* dtype, something that is hard to avoid when
building a separate independent dtype implementation for each na* dtype.</p>
<p>Reliable conversions with the NA bitpattern preserved across primitive
types requires consideration as well. Even in the simple case of
double -&gt; float, where this is supported by hardware, the NA value
will get lost because the NaN payload is typically not preserved.
The ability to have different bit masks specified for the same underlying
type also needs to convert properly. With a well-defined interface
converting to/from a (value,flag) pair, this becomes straightforward
to support generically.</p>
<p>This approach also provides some opportunities for some subtle variations
with IEEE floats. By default, one exact bit-pattern, a silent NaN with
a payload that won’t be generated by hardware floating point operations,
would be used. The choice R has made could be this default.</p>
<p>Additionally, it might be nice to sometimes treat all NaNs as missing values.
This requires a slightly more complex mapping to convert the floating point
values into mask/value combinations, and converting back would always
produce the default NaN used by NumPy. Finally, treating both NaNs
and Infs as missing values would be just a slight variation of the NaN
version.</p>
<p>Strings require a slightly different handling, because they
may be any size. One approach is to use a one-character signal consisting
of one of the first 32 ASCII/unicode values. There are many possible values
to use here, like 0x15 ‘Negative Acknowledgement’ or 0x10 ‘Data Link Escape’.</p>
<p>The Object dtype has an obvious signal, the np.NA singleton itself. Any
dtype with object semantics won’t be able to have this customized, since
specifying bit patterns applies only to plain binary data, not data
with object semantics of construction and destructions.</p>
<p>Struct dtypes are more of a core primitive dtype, in the same fashion that
this parameterized NA-capable dtype is. It won’t be possible to put
these as the parameter for the parameterized NA-dtype.</p>
<p>The dtype names would be parameterized similar to how the datetime64
is parameterized by the metadata unit. What name to use may require some
debate, but “NA” seems like a reasonable choice. With the default
missing value bit-pattern, these dtypes would look like
np.dtype(‘NA[float32]’), np.dtype(‘NA[f8]’), or np.dtype(‘NA[i64]’).</p>
<p>To override the bit pattern that signals a missing value, a raw
value in the format of a hexadecimal unsigned integer can be given,
and in the above special cases for floating point, special strings
can be provided. The defaults for some cases, written explicitly in this
form, are then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[?,0x02]&#39;</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[i4,0x80000000]&#39;</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[u4,0xffffffff]&#39;</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[f4,0x7f8007a2&#39;</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[f8,0x7ff00000000007a2&#39;</span><span class="p">)</span> <span class="p">(</span><span class="n">R</span><span class="o">-</span><span class="n">compatible</span> <span class="n">bitpattern</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[S16,0x15]&#39;</span><span class="p">)</span> <span class="p">(</span><span class="n">using</span> <span class="n">the</span> <span class="n">NAK</span> <span class="n">character</span> <span class="k">as</span> <span class="n">the</span> <span class="n">signal</span><span class="p">)</span><span class="o">.</span>

<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[f8,NaN]&#39;</span><span class="p">)</span> <span class="p">(</span><span class="k">for</span> <span class="nb">any</span> <span class="n">NaN</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;NA[f8,InfNaN]&#39;</span><span class="p">)</span> <span class="p">(</span><span class="k">for</span> <span class="nb">any</span> <span class="n">NaN</span> <span class="ow">or</span> <span class="n">Inf</span><span class="p">)</span>
</pre></div>
</div>
<p>When no parameter is specified a flexible NA dtype is created, which itself
cannot hold values, but will conform to the input types in functions like
‘np.astype’. The dtype ‘f8’ maps to ‘NA[f8]’, and [(‘a’, ‘f4’), (‘b’, ‘i4’)]
maps to [(‘a’, ‘NA[f4]’), (‘b’, ‘NA[i4]’)]. Thus, to view the memory
of an ‘f8’ array ‘arr’ with ‘NA[f8]’, you can say arr.view(dtype=’NA’).</p>
</section>
<section id="future-expansion-to-multi-na-payloads">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Future expansion to multi-NA payloads</a><a class="headerlink" href="#future-expansion-to-multi-na-payloads" title="Link to this heading">#</a></h3>
<p>The packages SAS and Stata both support multiple different “NA” values.
This allows one to specify different reasons for why a value, for
example homework that wasn’t done because the dog ate it or the student
was sick. In these packages, the different NA values have a linear ordering
which specifies how different NA values combine together.</p>
<p>In the sections on C implementation details, the mask has been designed
so that a mask with a payload is a strict superset of the NumPy boolean
type, and the boolean type has a payload of just zero. Different payloads
combine with the ‘min’ operation.</p>
<p>The important part of future-proofing the design is making sure
the C ABI-level choices and the Python API-level choices have a natural
transition to multi-NA support. Here is one way multi-NA support could look:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="n">maskna</span><span class="o">=</span><span class="s1">&#39;multi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">NA(1, dtype=&#39;&lt;i4&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="go">NA(2, dtype=&#39;&lt;i4&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">array([NA(0), 5, NA(2)], maskna=&#39;multi&#39;)</span>
</pre></div>
</div>
<p>The design of this NEP does not distinguish between NAs that come
from an NA mask or NAs that come from an NA dtype. Both of these get
treated equivalently in computations, with masks dominating over NA
dtypes.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;NA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">array([NA, NA, 12], maskna=True)</span>
</pre></div>
</div>
<p>The multi-NA approach allows one to distinguish between these NAs,
through assigning different payloads to the different types. If we
extend the ‘skipna=’ parameter to accept a list of payloads in addition
to True/False, one could do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="s1">&#39;multi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">7</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;NA[f4,multi]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="go">array([NA(1), NA(0), 12], maskna=&#39;multi&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">NA(1, dtype=&#39;&lt;i4&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">NA(0, dtype=&#39;&lt;f4&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">12</span>
</pre></div>
</div>
</section>
<section id="differences-with-numpy-ma">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Differences with numpy.ma</a><a class="headerlink" href="#differences-with-numpy-ma" title="Link to this heading">#</a></h3>
<p>The computational model that numpy.ma uses does not strictly adhere to
either the NA or the IGNORE model. This section exhibits some examples
of how these differences affect simple computations. This information
will be very important for helping users navigate between the systems,
so a summary probably should be put in a table in the documentation.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NA</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[0.110804969841 --]</span>
<span class="go"> [-- --]</span>
<span class="go"> [0.955128477746 0.440430735546]],</span>
<span class="go">             mask =</span>
<span class="go"> [[False  True]</span>
<span class="go"> [ True  True]</span>
<span class="go"> [False False]],</span>
<span class="go">       fill_value = 1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span>
<span class="go">array([[0.110804969841, NA],</span>
<span class="go">       [NA, NA],</span>
<span class="go">       [0.955128477746, 0.440430735546]],</span>
<span class="go">       maskna=True)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">masked_array(data = [0.532966723794 0.440430735546],</span>
<span class="go">             mask = [False False],</span>
<span class="go">       fill_value = 1e+20)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([NA, NA], dtype=&#39;&lt;f8&#39;, maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([0.532966723794 0.440430735546], maskna=True)</span>
</pre></div>
</div>
<p>For functions like np.mean, when ‘skipna=True’, the behavior
for all NAs is consistent with an empty array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">masked_array(data = [0.110804969841 -- 0.697779606646],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 1e+20)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([NA, NA, 0.697779606646], maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">RuntimeWarning: invalid value encountered in double_scalars</span>
<span class="go">array([0.110804969841, nan, 0.697779606646], maskna=True)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([])</span>
<span class="go">RuntimeWarning: invalid value encountered in double_scalars</span>
<span class="go">nan</span>
</pre></div>
</div>
<p>In particular, note that numpy.ma generally skips masked values,
except returns masked when all the values are masked, while
the ‘skipna=’ parameter returns zero when all the values are NA,
to be consistent with the result of np.sum([]):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">masked_array(data = [-- --],</span>
<span class="go">             mask = [ True  True],</span>
<span class="go">       fill_value = 1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([NA, NA], dtype=&#39;&lt;f8&#39;, maskna=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">NA(dtype=&#39;&lt;f8&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">0.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
</section>
<section id="boolean-indexing">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Boolean indexing</a><a class="headerlink" href="#boolean-indexing" title="Link to this heading">#</a></h3>
<p>Indexing using a boolean array containing NAs does not have a consistent
interpretation according to the NA abstraction. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="n">maskna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">What should happen here?</span>
</pre></div>
</div>
<p>Since the NA represents a valid but unknown value, and it is a boolean,
it has two possible underlying values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">])]</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])]</span>
<span class="go">array([2])</span>
</pre></div>
</div>
<p>The thing which changes is the length of the output array, nothing which
itself can be substituted for NA. For this reason, at least initially,
NumPy will raise an exception for this case.</p>
<p>Another possibility is to add an inconsistency, and follow the approach
R uses. That is, to produce the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="go">array([NA, 2], maskna=True)</span>
</pre></div>
</div>
<p>If, in user testing, this is found necessary for pragmatic reasons,
the feature should be added even though it is inconsistent.</p>
</section>
<section id="pep-3118">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">PEP 3118</a><a class="headerlink" href="#pep-3118" title="Link to this heading">#</a></h3>
<p>PEP 3118 doesn’t have any mask mechanism, so arrays with masks will
not be accessible through this interface. Similarly, it doesn’t support
the specification of dtypes with NA or IGNORE bitpatterns, so the
parameterized NA dtypes will also not be accessible through this interface.</p>
<p>If NumPy did allow access through PEP 3118, this would circumvent the
missing value abstraction in a very damaging way. Other libraries would
try to use masked arrays, and silently get access to the data without
also getting access to the mask or being aware of the missing value
abstraction the mask and data together are following.</p>
</section>
<section id="cython">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Cython</a><a class="headerlink" href="#cython" title="Link to this heading">#</a></h3>
<p>Cython uses PEP 3118 to work with NumPy arrays, so currently it will
simply refuse to work with them as described in the “PEP 3118” section.</p>
<p>In order to properly support NumPy missing values, Cython will need to
be modified in some fashion to add this support. Likely the best way
to do this will be to include it with supporting np.nditer, which
is most likely going to have an enhancement to make writing missing
value algorithms easier.</p>
</section>
<section id="hard-masks">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Hard masks</a><a class="headerlink" href="#hard-masks" title="Link to this heading">#</a></h3>
<p>The numpy.ma implementation has a “hardmask” feature,
which prevents values from ever being unmasked by assigning a value.
This would be an internal array flag, named something like
‘arr.flags.hardmask’.</p>
<p>If the hardmask feature is implemented, boolean indexing could
return a hardmasked array instead of a flattened array with the
arbitrary choice of C-ordering as it currently does. While this
improves the abstraction of the array significantly, it is not
a compatible change.</p>
</section>
<section id="shared-masks">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Shared masks</a><a class="headerlink" href="#shared-masks" title="Link to this heading">#</a></h3>
<p>One feature of numpy.ma is called ‘shared masks’.</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.sharedmask">https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.sharedmask</a></p>
<p>This feature cannot be supported by a masked implementation of
missing values without directly violating the missing value abstraction.
If the same mask memory is shared between two arrays ‘a’ and ‘b’, assigning
a value to a masked element in ‘a’ will simultaneously unmask the
element with matching index in ‘b’. Because this isn’t at the same time
assigning a valid value to that element in ‘b’, this has violated the
abstraction. For this reason, shared masks will not be supported
by the mask-based missing value implementation.</p>
<p>This is slightly different from what happens when taking a view
of an array with masked missing value support, where a view of
both the mask and the data are taken simultaneously. The result
is two views which share the same mask memory and the same data memory,
which still preserves the missing value abstraction.</p>
</section>
<section id="interaction-with-pre-existing-c-api-usage">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Interaction with pre-existing C API usage</a><a class="headerlink" href="#interaction-with-pre-existing-c-api-usage" title="Link to this heading">#</a></h3>
<p>Making sure existing code using the C API, whether it’s written in C, C++,
or Cython, does something reasonable is an important goal of this implementation.
The general strategy is to make existing code which does not explicitly
tell numpy it supports NA masks fail with an exception saying so. There are
a few different access patterns people use to get ahold of the numpy array data,
here we examine a few of them to see what numpy can do. These examples are
found from doing google searches of numpy C API array access.</p>
<section id="numpy-documentation-how-to-extend-numpy">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">NumPy documentation - how to extend NumPy</a><a class="headerlink" href="#numpy-documentation-how-to-extend-numpy" title="Link to this heading">#</a></h4>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy/user/c-info.how-to-extend.html#dealing-with-array-objects">https://docs.scipy.org/doc/numpy/user/c-info.how-to-extend.html#dealing-with-array-objects</a></p>
<p>This page has a section “Dealing with array objects” which has some advice for how
to access numpy arrays from C. When accepting arrays, the first step it suggests is
to use PyArray_FromAny or a macro built on that function, so code following this
advice will properly fail when given an NA-masked array it doesn’t know how to handle.</p>
<p>The way this is handled is that PyArray_FromAny requires a special flag, NPY_ARRAY_ALLOWNA,
before it will allow NA-masked arrays to flow through.</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/c-api.array.html#NPY_ARRAY_ALLOWNA">https://docs.scipy.org/doc/numpy/reference/c-api.array.html#NPY_ARRAY_ALLOWNA</a></p>
<p>Code which does not follow this advice, and instead just calls PyArray_Check() to verify
it is an ndarray and checks some flags, will silently produce incorrect results. This style
of code does not provide any opportunity for numpy to say “hey, this array is special”,
so also is not compatible with future ideas of lazy evaluation, derived dtypes, etc.</p>
</section>
<section id="tutorial-from-cython-website">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">Tutorial from Cython website</a><a class="headerlink" href="#tutorial-from-cython-website" title="Link to this heading">#</a></h4>
<p><a class="reference external" href="http://docs.cython.org/src/tutorial/numpy.html">http://docs.cython.org/src/tutorial/numpy.html</a></p>
<p>This tutorial gives a convolution example, and all the examples fail with
Python exceptions when given inputs that contain NA values.</p>
<p>Before any Cython type annotation is introduced, the code functions just
as equivalent Python would in the interpreter.</p>
<p>When the type information is introduced, it is done via numpy.pxd which
defines a mapping between an ndarray declaration and PyArrayObject *.
Under the hood, this maps to __Pyx_ArgTypeTest, which does a direct
comparison of Py_TYPE(obj) against the PyTypeObject for the ndarray.</p>
<p>Then the code does some dtype comparisons, and uses regular python indexing
to access the array elements. This python indexing still goes through the
Python API, so the NA handling and error checking in numpy still can work
like normal and fail if the inputs have NAs which cannot fit in the output
array. In this case it fails when trying to convert the NA into an integer
to set in the output.</p>
<p>The next version of the code introduces more efficient indexing. This
operates based on Python’s buffer protocol. This causes Cython to call
__Pyx_GetBufferAndValidate, which calls __Pyx_GetBuffer, which calls
PyObject_GetBuffer. This call gives numpy the opportunity to raise an
exception if the inputs are arrays with NA-masks, something not supported
by the Python buffer protocol.</p>
</section>
<section id="numerical-python-jpl-website">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Numerical Python - JPL website</a><a class="headerlink" href="#numerical-python-jpl-website" title="Link to this heading">#</a></h4>
<p><a class="reference external" href="http://dsnra.jpl.nasa.gov/software/Python/numpydoc/numpy-13.html">http://dsnra.jpl.nasa.gov/software/Python/numpydoc/numpy-13.html</a></p>
<p>This document is from 2001, so does not reflect recent numpy, but it is the
second hit when searching for “numpy c api example” on google.</p>
<p>There first example, heading “A simple example”, is in fact already invalid for
recent numpy even without the NA support. In particular, if the data is misaligned
or in a different byteorder, it may crash or produce incorrect results.</p>
<p>The next thing the document does is introduce PyArray_ContiguousFromObject, which
gives numpy an opportunity to raise an exception when NA-masked arrays are used,
so the later code will raise exceptions as desired.</p>
</section>
</section>
</section>
<section id="c-implementation-details">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">C implementation details</a><a class="headerlink" href="#c-implementation-details" title="Link to this heading">#</a></h2>
<p>The first version to implement is the array masks, because it is
the more general approach. The mask itself is an array, but since
it is intended to never be directly accessible from Python, it won’t
be a full ndarray itself. The mask always has the same shape as
the array it is attached to, so it doesn’t need its own shape. For
an array with a struct dtype, however, the mask will have a different
dtype than just a straight bool, so it does need its own dtype.
This gives us the following additions to the PyArrayObject:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Descriptor for the mask dtype.</span>
<span class="cm"> *   If no mask: NULL</span>
<span class="cm"> *   If mask   : bool/uint8/structured dtype of mask dtypes</span>
<span class="cm"> */</span>
<span class="n">PyArray_Descr</span><span class="w"> </span><span class="o">*</span><span class="n">maskna_dtype</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Raw data buffer for mask. If the array has the flag</span>
<span class="cm"> * NPY_ARRAY_OWNMASKNA enabled, it owns this memory and</span>
<span class="cm"> * must call PyArray_free on it when destroyed.</span>
<span class="cm"> */</span>
<span class="n">npy_mask</span><span class="w"> </span><span class="o">*</span><span class="n">maskna_data</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Just like dimensions and strides point into the same memory</span>
<span class="cm"> * buffer, we now just make the buffer 3x the nd instead of 2x</span>
<span class="cm"> * and use the same buffer.</span>
<span class="cm"> */</span>
<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span><span class="n">maskna_strides</span><span class="p">;</span>
</pre></div>
</div>
<p>These fields can be accessed through the inline functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyArray_Descr</span><span class="w"> </span><span class="o">*</span>
<span class="nf">PyArray_MASKNA_DTYPE</span><span class="p">(</span><span class="n">PyArrayObject</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>

<span class="n">npy_mask</span><span class="w"> </span><span class="o">*</span>
<span class="nf">PyArray_MASKNA_DATA</span><span class="p">(</span><span class="n">PyArrayObject</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>

<span class="n">npy_intp</span><span class="w"> </span><span class="o">*</span>
<span class="nf">PyArray_MASKNA_STRIDES</span><span class="p">(</span><span class="n">PyArrayObject</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>

<span class="n">npy_bool</span>
<span class="nf">PyArray_HASMASKNA</span><span class="p">(</span><span class="n">PyArrayObject</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
</pre></div>
</div>
<p>There are 2 or 3 flags which must be added to the array flags, both
for requesting NA masks and for testing for them:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NPY_ARRAY_MASKNA</span>
<span class="n">NPY_ARRAY_OWNMASKNA</span>
<span class="cm">/* To possibly add in a later revision */</span>
<span class="n">NPY_ARRAY_HARDMASKNA</span>
</pre></div>
</div>
<p>To allow the easy detection of NA support, and whether an array
has any missing values, we add the following functions:</p>
<dl class="simple">
<dt>PyDataType_HasNASupport(PyArray_Descr* dtype)</dt><dd><p>Returns true if this is an NA dtype, or a struct
dtype where every field has NA support.</p>
</dd>
<dt>PyArray_HasNASupport(PyArrayObject* obj)</dt><dd><p>Returns true if the array dtype has NA support, or
the array has an NA mask.</p>
</dd>
<dt>PyArray_ContainsNA(PyArrayObject* obj)</dt><dd><p>Returns false if the array has no NA support. Returns
true if the array has NA support AND there is an
NA anywhere in the array.</p>
</dd>
<dt>int PyArray_AllocateMaskNA(PyArrayObject* arr, npy_bool ownmaskna, npy_bool multina)</dt><dd><p>Allocates an NA mask for the array, ensuring ownership if requested
and using NPY_MASK instead of NPY_BOOL for the dtype if multina is True.</p>
</dd>
</dl>
<section id="mask-binary-format">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">Mask binary format</a><a class="headerlink" href="#mask-binary-format" title="Link to this heading">#</a></h3>
<p>The format of the mask itself is designed to indicate whether an
element is masked or not, as well as contain a payload so that multiple
different NAs with different payloads can be used in the future.
Initially, we will simply use the payload 0.</p>
<p>The mask has type npy_uint8, and bit 0 is used to indicate whether
a value is masked. If ((m&amp;0x01) == 0), the element is masked, otherwise
it is unmasked. The rest of the bits are the payload, which is (m&gt;&gt;1).
The convention for combining masks with payloads is that smaller
payloads propagate. This design gives 128 payload values to masked elements,
and 128 payload values to unmasked elements.</p>
<p>The big benefit of this approach is that npy_bool also
works as a mask, because it takes on the values 0 for False and 1
for True. Additionally, the payload for npy_bool, which is always
zero, dominates over all the other possible payloads.</p>
<p>Since the design involves giving the mask its own dtype, we can
distinguish between masking with a single NA value (npy_bool mask),
and masking with multi-NA (npy_uint8 mask). Initial implementations
will just support the npy_bool mask.</p>
<p>An idea that was discarded is to allow the combination of masks + payloads
to be a simple ‘min’ operation. This can be done by putting the payload
in bits 0 through 6, so that the payload is (m&amp;0x7f), and using bit 7
for the masking flag, so ((m&amp;0x80) == 0) means the element is masked.
The fact that this makes masks completely different from booleans, instead
of a strict superset, is the primary reason this choice was discarded.</p>
</section>
</section>
<section id="c-iterator-api-changes-iteration-with-masks">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">C iterator API changes: iteration with masks</a><a class="headerlink" href="#c-iterator-api-changes-iteration-with-masks" title="Link to this heading">#</a></h2>
<p>For iteration and computation with masks, both in the context of missing
values and when the mask is used like the ‘where=’ parameter in ufuncs,
extending the nditer is the most natural way to expose this functionality.</p>
<p>Masked operations need to work with casting, alignment, and anything else
which causes values to be copied into a temporary buffer, something which
is handled nicely by the nditer but difficult to do outside that context.</p>
<p>First we describe iteration designed for use of masks outside the
context of missing values, then the features which include missing
value support.</p>
<section id="iterator-mask-features">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Iterator mask features</a><a class="headerlink" href="#iterator-mask-features" title="Link to this heading">#</a></h3>
<p>We add several new per-operand flags:</p>
<dl>
<dt>NPY_ITER_WRITEMASKED</dt><dd><p>Indicates that any copies done from a buffer to the array are
masked. This is necessary because READWRITE mode could destroy
data if a float array was being treated like an int array, so
copying to the buffer and back would truncate to integers. No
similar flag is provided for reading, because it may not be possible
to know the mask ahead of time, and copying everything into
the buffer will never destroy data.</p>
<p>The code using the iterator should only write to values which
are not masked by the mask specified, otherwise the result will
be different depending on whether buffering is enabled or not.</p>
</dd>
<dt>NPY_ITER_ARRAYMASK</dt><dd><p>Indicates that this array is a boolean mask to use when copying
any WRITEMASKED argument from a buffer back to the array. There
can be only one such mask, and there cannot also be a virtual
mask.</p>
<p>As a special case, if the flag NPY_ITER_USE_MASKNA is specified
at the same time, the mask for the operand is used instead
of the operand itself. If the operand has no mask but is
based on an NA dtype, that mask exposed by the iterator converts
into the NA bitpattern when copying from the buffer to the
array.</p>
</dd>
<dt>NPY_ITER_VIRTUAL</dt><dd><p>Indicates that this operand is not an array, but rather created on
the fly for the inner iteration code. This allocates enough buffer
space for the code to read/write data, but does not have
an actual array backing the data. When combined with NPY_ITER_ARRAYMASK,
allows for creating a “virtual mask”, specifying which values
are unmasked without ever creating a full mask array.</p>
</dd>
</dl>
</section>
<section id="iterator-na-array-features">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">Iterator NA-array features</a><a class="headerlink" href="#iterator-na-array-features" title="Link to this heading">#</a></h3>
<p>We add several new per-operand flags:</p>
<dl>
<dt>NPY_ITER_USE_MASKNA</dt><dd><p>If the operand has an NA dtype, an NA mask, or both, this adds a new
virtual operand to the end of the operand list which iterates
over the mask for the particular operand.</p>
</dd>
<dt>NPY_ITER_IGNORE_MASKNA</dt><dd><p>If an operand has an NA mask, by default the iterator will raise
an exception unless NPY_ITER_USE_MASKNA is specified. This flag
disables that check, and is intended for cases where one has first
checked that all the elements in the array are not NA using the
PyArray_ContainsNA function.</p>
<p>If the dtype is an NA dtype, this also strips the NA-ness from the
dtype, showing a dtype that does not support NA.</p>
</dd>
</dl>
</section>
</section>
<section id="rejected-alternative">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">Rejected alternative</a><a class="headerlink" href="#rejected-alternative" title="Link to this heading">#</a></h2>
<section id="parameterized-data-type-which-adds-additional-memory-for-the-na-flag">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Parameterized data type which adds additional memory for the NA flag</a><a class="headerlink" href="#parameterized-data-type-which-adds-additional-memory-for-the-na-flag" title="Link to this heading">#</a></h3>
<p>Another alternative to having a separate mask added to the array is
to introduced a parameterized type, which takes a primitive dtype
as an argument. The dtype “i8” would turn into “maybe[i8]”, and
a byte flag would be appended to the dtype to indicate whether the
value was NA or not.</p>
<p>This approach adds memory overhead greater or equal to keeping a separate
mask, but has better locality. To keep the dtype aligned, an ‘i8’ would
need to have 16 bytes to retain proper alignment, a 100% overhead compared
to 12.5% overhead for a separately kept mask.</p>
</section>
</section>
<section id="acknowledgments">
<h2><a class="toc-backref" href="#id39" role="doc-backlink">Acknowledgments</a><a class="headerlink" href="#acknowledgments" title="Link to this heading">#</a></h2>
<p>In addition to feedback from Travis Oliphant and others at Enthought,
this NEP has been revised based on a great deal of feedback from
the NumPy-Discussion mailing list. The people participating in
the discussion are:</p>
<ul class="simple">
<li><p>Nathaniel Smith</p></li>
<li><p>Robert Kern</p></li>
<li><p>Charles Harris</p></li>
<li><p>Gael Varoquaux</p></li>
<li><p>Eric Firing</p></li>
<li><p>Keith Goodman</p></li>
<li><p>Pierre GM</p></li>
<li><p>Christopher Barker</p></li>
<li><p>Josef Perktold</p></li>
<li><p>Ben Root</p></li>
<li><p>Laurent Gautier</p></li>
<li><p>Neal Becker</p></li>
<li><p>Bruce Southey</p></li>
<li><p>Matthew Brett</p></li>
<li><p>Wes McKinney</p></li>
<li><p>Lluís</p></li>
<li><p>Olivier Delalleau</p></li>
<li><p>Alan G Isaac</p></li>
<li><ol class="upperalpha simple" start="5">
<li><p>Antero Tammi</p></li>
</ol>
</li>
<li><p>Jason Grout</p></li>
<li><p>Dag Sverre Seljebotn</p></li>
<li><p>Joe Harrington</p></li>
<li><p>Gary Strangman</p></li>
<li><p>Chris Jordan-Squire</p></li>
<li><p>Peter</p></li>
</ul>
<p>I apologize if I missed anyone.</p>
</section>
</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table-of-contents">Table of contents</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract">Abstract</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#definition-of-missing-data">Definition of missing data</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unknown-yet-existing-data-na">Unknown yet existing data (NA)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-that-doesn-t-exist-or-is-being-skipped-ignore">Data that doesn’t exist or is being skipped (IGNORE)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation-techniques-for-missing-values">Implementation techniques for missing values</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bit-patterns-signalling-missing-values-bitpattern">Bit patterns signalling missing values (bitpattern)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boolean-masks-signalling-missing-values-mask">Boolean masks signalling missing values (mask)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-of-terms">Glossary of terms</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#missing-values-as-seen-in-python">Missing values as seen in Python</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#working-with-missing-values">Working with missing values</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#accessing-a-boolean-mask">Accessing a boolean mask</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-na-masked-arrays">Creating NA-masked arrays</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#na-masks-when-constructing-from-lists">Na-masks when constructing from lists</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-implementation-details">Mask implementation details</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#new-ndarray-methods">New ndarray methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#element-wise-ufuncs-with-missing-values">Element-wise ufuncs with missing values</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reduction-ufuncs-with-missing-values">Reduction ufuncs with missing values</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parameterized-na-data-types">Parameterized NA data types</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#future-expansion-to-multi-na-payloads">Future expansion to multi-NA payloads</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#differences-with-numpy-ma">Differences with numpy.ma</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boolean-indexing">Boolean indexing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pep-3118">PEP 3118</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cython">Cython</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hard-masks">Hard masks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-masks">Shared masks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interaction-with-pre-existing-c-api-usage">Interaction with pre-existing C API usage</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy-documentation-how-to-extend-numpy">NumPy documentation - how to extend NumPy</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tutorial-from-cython-website">Tutorial from Cython website</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-python-jpl-website">Numerical Python - JPL website</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c-implementation-details">C implementation details</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mask-binary-format">Mask binary format</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#c-iterator-api-changes-iteration-with-masks">C iterator API changes: iteration with masks</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterator-mask-features">Iterator mask features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iterator-na-array-features">Iterator NA-array features</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rejected-alternative">Rejected alternative</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parameterized-data-type-which-adds-additional-memory-for-the-na-flag">Parameterized data type which adds additional memory for the NA flag</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#acknowledgments">Acknowledgments</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2017-2025, NumPy Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>