
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NEP 26 — Summary of missing data NEPs and discussion &#8212; NumPy Enhancement Proposals</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="_static/documentation_options.js?v=7f41d439"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'nep-0026-missing-data-summary';</script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="NEP 30 — Duck typing for NumPy arrays - implementation" href="nep-0030-duck-array-protocol.html" />
    <link rel="prev" title="NEP 25 — NA support via special dtypes" href="nep-0025-missing-data-3.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
    <meta name="docbuild:last-update" content="Nov 01, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="content.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/numpylogo.svg" class="logo__image only-light" alt="NumPy Enhancement Proposals - Home"/>
    <img src="_static/numpylogo_dark.svg" class="logo__image only-dark pst-js-only" alt="NumPy Enhancement Proposals - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="scope.html">The Scope of NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Current roadmap</a></li>
</ul>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="meta.html">Meta-NEPs (NEPs about NEPs or active Processes)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0000.html">NEP 0 — Purpose and process</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0023-backwards-compatibility.html">NEP 23 — Backwards compatibility and deprecation policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0036-fair-play.html">NEP 36 — Fair play</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0045-c_style_guide.html">NEP 45 — C style guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0046-sponsorship-guidelines.html">NEP 46 — NumPy sponsorship guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0048-spending-project-funds.html">NEP 48 — Spending NumPy project funds</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-template.html">NEP X — Template and instructions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="provisional.html">Provisional NEPs (provisionally accepted; interface may change)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="accepted.html">Accepted NEPs (implementation in progress)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0041-improved-dtype-support.html">NEP 41 — First step towards a new datatype system</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0042-new-dtypes.html">NEP 42 — New and extensible DTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0044-restructuring-numpy-docs.html">NEP 44 — Restructuring the NumPy documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0051-scalar-representation.html">NEP 51 — Changing the representation of NumPy scalars</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0054-simd-cpp-highway.html">NEP 54 — SIMD infrastructure evolution: adopting Google Highway when moving to C++</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="open.html">Open NEPs (under consideration)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0043-extensible-ufuncs.html">NEP 43 — Enhancing the extensibility of UFuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0053-c-abi-evolution.html">NEP 53 — Evolving the NumPy C-API for NumPy 2.0</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="finished.html">Finished NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0001-npy-format.html">NEP 1 — A simple file format for NumPy arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0005-generalized-ufuncs.html">NEP 5 — Generalized universal functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0007-datetime-proposal.html">NEP 7 — A proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0010-new-iterator-ufunc.html">NEP 10 — Optimizing iterator/UFunc performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0013-ufunc-overrides.html">NEP 13 — A mechanism for overriding Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0014-dropping-python2.7-proposal.html">NEP 14 — Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0015-merge-multiarray-umath.html">NEP 15 — Merging multiarray and umath</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0018-array-function-protocol.html">NEP 18 — A dispatch mechanism for NumPy's high level array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0019-rng-policy.html">NEP 19 — Random number generator policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0020-gufunc-signature-enhancement.html">NEP 20 — Expansion of generalized universal function signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0022-ndarray-duck-typing-overview.html">NEP 22 — Duck typing for NumPy arrays – high level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0027-zero-rank-arrarys.html">NEP 27 — Zero rank arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0028-website-redesign.html">NEP 28 — numpy.org website redesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0029-deprecation_policy.html">NEP 29 — Recommend Python and NumPy version support as a community policy standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0032-remove-financial-functions.html">NEP 32 — Remove the financial functions from NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0034-infer-dtype-is-object.html">NEP 34 — Disallow inferring ``dtype=object`` from sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0035-array-creation-dispatch-with-array-function.html">NEP 35 — Array creation dispatching with __array_function__</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0038-SIMD-optimizations.html">NEP 38 — Using SIMD optimization instructions for performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0040-legacy-datatype-impl.html">NEP 40 — Legacy datatype implementation in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0049-data-allocation-strategies.html">NEP 49 — Data allocation strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0050-scalar-promotion.html">NEP 50 — Promotion rules for Python scalars</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0052-python-api-cleanup.html">NEP 52 — Python API cleanup for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0055-string_dtype.html">NEP 55 — Add a UTF-8 variable-width string DType to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0056-array-api-main-namespace.html">NEP 56 — Array API standard support in NumPy's main namespace</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="deferred.html">Deferred and Superseded NEPs</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nep-0002-warnfix.html">NEP 2 — A proposal to build numpy without warning with a big set of warning flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0003-math_config_clean.html">NEP 3 — Cleaning the math configuration of numpy.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0004-datetime-proposal3.html">NEP 4 — A (third) proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0006-newbugtracker.html">NEP 6 — Replacing Trac with a different bug tracker</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0008-groupby_additions.html">NEP 8 — A proposal for adding groupby functionality to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0009-structured_array_extensions.html">NEP 9 — Structured array extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0011-deferred-ufunc-evaluation.html">NEP 11 — Deferred UFunc evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0012-missing-data.html">NEP 12 — Missing data functionality in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0021-advanced-indexing.html">NEP 21 — Simplified and explicit advanced indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0024-missing-data-2.html">NEP 24 — Missing data functionality - alternative 1 to NEP 12</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0025-missing-data-3.html">NEP 25 — NA support via special dtypes</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">NEP 26 — Summary of missing data NEPs and discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0030-duck-array-protocol.html">NEP 30 — Duck typing for NumPy arrays - implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0031-uarray.html">NEP 31 — Context-local and global overrides of the NumPy API</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0037-array-module.html">NEP 37 — A dispatch protocol for NumPy-like modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0047-array-api-standard.html">NEP 47 — Adopting the array API standard</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="rejected.html">Rejected and Withdrawn NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0016-abstract-array.html">NEP 16 — An abstract base class for identifying "duck arrays"</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0017-split-out-maskedarray.html">NEP 17 — Split out masked arrays</a></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="content.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Roadmap &amp; NumPy enhancement proposals</a></li>
    
    
    <li class="breadcrumb-item"><a href="deferred.html" class="nav-link">Deferred and Superseded NEPs</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">NEP 26 — Summary of missing data NEPs and discussion</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="nep-26-summary-of-missing-data-neps-and-discussion">
<span id="nep26"></span><h1>NEP 26 — Summary of missing data NEPs and discussion<a class="headerlink" href="#nep-26-summary-of-missing-data-neps-and-discussion" title="Link to this heading">#</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mark Wiebe &lt;<a class="reference external" href="mailto:mwwiebe&#37;&#52;&#48;gmail&#46;com">mwwiebe<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;, Nathaniel J. Smith &lt;<a class="reference external" href="mailto:njs&#37;&#52;&#48;pobox&#46;com">njs<span>&#64;</span>pobox<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><p>Deferred</p>
</dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Standards Track</p>
</dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even"><p>2012-04-22</p>
</dd>
</dl>
<p><em>Context</em>: this NEP was written as summary of the large number of discussions
and proposals (<a class="reference internal" href="nep-0012-missing-data.html#nep12"><span class="std std-ref">NEP 12 — Missing data functionality in NumPy</span></a>, <a class="reference internal" href="nep-0024-missing-data-2.html#nep24"><span class="std std-ref">NEP 24 — Missing data functionality - alternative 1 to NEP 12</span></a>, <a class="reference internal" href="nep-0025-missing-data-3.html#nep25"><span class="std std-ref">NEP 25 — NA support via special dtypes</span></a>), regarding missing data
functionality.</p>
<p>The debate about how NumPy should handle missing data, a subject with
many preexisting approaches, requirements, and conventions, has been long and
contentious. There has been more than one proposal for how to implement
support into NumPy, and there is a testable implementation which is
merged into NumPy’s current main. The vast number of emails and differing
points of view has made it difficult for interested parties to understand
the issues and be comfortable with the direction NumPy is going.</p>
<p>Here is our (Mark and Nathaniel’s) attempt to summarize the
problem, proposals, and points of agreement/disagreement in a single
place, to help the community move towards consensus.</p>
<section id="the-numpy-developers-problem">
<h2>The NumPy developers’ problem<a class="headerlink" href="#the-numpy-developers-problem" title="Link to this heading">#</a></h2>
<p>For this discussion, “missing data” means array elements
which can be indexed (e.g. A[3] in an array A with shape (5,)),
but have, in some sense, no value.</p>
<p>It does not refer to compressed or sparse storage techniques where
the value for A[3] is not actually stored in memory, but still has a
well-defined value like 0.</p>
<p>This is still vague, and to create an actual implementation,
it is necessary to answer such questions as:</p>
<ul class="simple">
<li><p>What values are computed when doing element-wise ufuncs.</p></li>
<li><p>What values are computed when doing reductions.</p></li>
<li><p>Whether the storage for an element gets overwritten when marking
that value missing.</p></li>
<li><p>Whether computations resulting in NaN automatically treat in the
same way as a missing value.</p></li>
<li><p>Whether one interacts with missing values using a placeholder object
(e.g. called “NA” or “masked”), or through a separate boolean array.</p></li>
<li><p>Whether there is such a thing as an array object that cannot hold
missing array elements.</p></li>
<li><p>How the (C and Python) API is expressed, in terms of dtypes,
masks, and other constructs.</p></li>
<li><p>If we decide to answer some of these questions in multiple ways,
then that creates the question of whether that requires multiple
systems, and if so how they should interact.</p></li>
</ul>
<p>There’s clearly a very large space of missing-data APIs that <em>could</em>
be implemented. There is likely at least one user, somewhere, who
would find any possible implementation to be just the thing they
need to solve some problem. On the other hand, much of NumPy’s power
and clarity comes from having a small number of orthogonal concepts,
such as strided arrays, flexible indexing, broadcasting, and ufuncs,
and we’d like to preserve that simplicity.</p>
<p>There has been dissatisfaction among several major groups of NumPy users
about the existing status quo of missing data support. In particular,
neither the numpy.ma component nor use of floating-point NaNs as a
missing data signal fully satisfy the performance requirements and
ease of use for these users. The example of R, where missing data
is treated via an NA placeholder and is deeply integrated into all
computation, is where many of these users point to indicate what
functionality they would like. Doing a deep integration of missing
data like in R must be considered carefully, it must be clear it
is not being done in a way which sacrifices existing performance
or functionality.</p>
<p>Our problem is, how can we choose some incremental additions to
NumPy that will make a large class of users happy, be
reasonably elegant, complement the existing design, and that we’re
comfortable we won’t regret being stuck with in the long term.</p>
</section>
<section id="prior-art">
<h2>Prior art<a class="headerlink" href="#prior-art" title="Link to this heading">#</a></h2>
<p>So a major (maybe <em>the</em> major) problem is figuring out how ambitious
the project to add missing data support to NumPy should be, and which
kinds of problems are in scope. Let’s start with the
best understood situation where “missing data” comes into play:</p>
<section id="statistical-missing-data">
<h3>“Statistical missing data”<a class="headerlink" href="#statistical-missing-data" title="Link to this heading">#</a></h3>
<p>In statistics, social science, etc., “missing data” is a term of art
referring to a specific (but extremely common and important)
situation: we have tried to gather some measurements according to some
scheme, but some of these measurements are missing. For example, if we
have a table listing the height, age, and income of a number of
individuals, but one person did not provide their income, then we need
some way to represent this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Person</span> <span class="o">|</span> <span class="n">Height</span> <span class="o">|</span> <span class="n">Age</span> <span class="o">|</span> <span class="n">Income</span>
<span class="o">------------------------------</span>
   <span class="mi">1</span>   <span class="o">|</span>   <span class="mi">63</span>   <span class="o">|</span> <span class="mi">25</span>  <span class="o">|</span> <span class="mi">15000</span>
   <span class="mi">2</span>   <span class="o">|</span>   <span class="mi">58</span>   <span class="o">|</span> <span class="mi">32</span>  <span class="o">|</span> <span class="o">&lt;</span><span class="n">missing</span><span class="o">&gt;</span>
   <span class="mi">3</span>   <span class="o">|</span>   <span class="mi">71</span>   <span class="o">|</span> <span class="mi">45</span>  <span class="o">|</span> <span class="mi">30000</span>
</pre></div>
</div>
<p>The traditional way is to record that income as, say, “-99”, and
document this in the README along with the data set. Then, you have to
remember to check for and handle such incomes specially; if you
forget, you’ll get superficially reasonable but completely incorrect
results, like calculating the average income on this data set as
14967. If you’re in one of these fields, then such missing-ness is
routine and inescapable, and if you use the “-99” approach then it’s a
pitfall you have to remember to check for explicitly on literally
<em>every</em> calculation you ever do. This is, obviously, an unpleasant way
to live.</p>
<p>Let’s call this situation the “statistical missing data” situation,
just to have a convenient handle for it. (As mentioned, practitioners
just call this “missing data”, and what to do about it is literally an
entire sub-field of statistics; if you google “missing data” then
every reference is on how to handle it.) NumPy isn’t going to do
automatic imputation or anything like that, but it could help a great
deal by providing some standard way to at least represent data which
is missing in this sense.</p>
<p>The main prior art for how this could be done comes from the S/S+/R
family of languages. Their strategy is, for each type they support,
to define a special value called “NA”. (For ints this is INT_MAX,
for floats it’s a special NaN value that’s distinguishable from
other NaNs, …) Then, they arrange that in computations, this
value has a special semantics that we will call “NA semantics”.</p>
</section>
<section id="na-semantics">
<h3>NA semantics<a class="headerlink" href="#na-semantics" title="Link to this heading">#</a></h3>
<p>The idea of NA semantics is that any computations involving NA
values should be consistent with what would have happened if we
had known the correct value.</p>
<p>For example, let’s say we want to compute the mean income, how might
we do this? One way would be to just ignore the missing entry, and
compute the mean of the remaining entries. This gives us (15000 +
30000)/2, or 22500.</p>
<p>Is this result consistent with discovering the income of person 2?
Let’s say we find out that person 2’s income is 50000. This means
the correct answer is (15000 + 50000 + 30000)/3, or 31666.67,
indicating clearly that it is not consistent. Therefore, the mean
income is NA, i.e. a specific number whose value we are unable
to compute.</p>
<p>This motivates the following rules, which are how R implements NA:</p>
<dl>
<dt>Assignment:</dt><dd><p>NA values are understood to represent specific
unknown values, and thus should have value-like semantics with
respect to assignment and other basic data manipulation
operations. Code which does not actually look at the values involved
should work the same regardless of whether some of them are
missing. For example, one might write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">income</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">income</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">height</span><span class="p">)]</span>
</pre></div>
</div>
<p>to perform an in-place sort of the <code class="docutils literal notranslate"><span class="pre">income</span></code> array, and know that
the shortest person’s income would end up being first. It turns out
that the shortest person’s income is not known, so the array should
end up being <code class="docutils literal notranslate"><span class="pre">[NA,</span> <span class="pre">15000,</span> <span class="pre">30000]</span></code>, but there’s nothing
special about NAness here.</p>
</dd>
<dt>Propagation:</dt><dd><p>In the example above, we concluded that an operation like <code class="docutils literal notranslate"><span class="pre">mean</span></code>
should produce NA when one of its data values was NA.
If you ask me, “what is 3 plus x?”, then my only possible answer is
“I don’t know what x is, so I don’t know what 3 + x is either”. NA
means “I don’t know”, so 3 + NA is NA.</p>
<p>This is important for safety when analyzing data: missing data often
requires special handling for correctness – the fact that you are
missing information might mean that something you wanted to compute
cannot actually be computed, and there are whole books written on
how to compensate in various situations. Plus, it’s easy to not
realize that you have missing data, and write code that assumes you
have all the data. Such code should not silently produce the wrong
answer.</p>
<p>There is an important exception to characterizing this as propagation,
in the case of boolean values. Consider the calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">NA</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
</pre></div>
</div>
<p>If we strictly propagate, <code class="docutils literal notranslate"><span class="pre">v</span></code> will become NA. However, no
matter whether we place True or False into the third array position,
<code class="docutils literal notranslate"><span class="pre">v</span></code> will then get the value True. The answer to the question
“Is the result True consistent with later discovering the value
that was missing?” is yes, so it is reasonable to not propagate here,
and instead return the value True. This is what R does:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">NA</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">TRUE</span>
<span class="o">&gt;</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">NA</span><span class="p">,</span> <span class="n">F</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">NA</span>
</pre></div>
</div>
</dd>
<dt>Other:</dt><dd><p>NaN and NA are conceptually distinct. 0.0/0.0 is not a mysterious,
unknown value – it’s defined to be NaN by IEEE floating point, Not
a Number. NAs are numbers (or strings, or whatever), just unknown
ones. Another small but important difference is that in Python, <code class="docutils literal notranslate"><span class="pre">if</span>
<span class="pre">NaN:</span> <span class="pre">...</span></code> treats NaN as True (NaN is “truthy”); but <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">NA:</span> <span class="pre">...</span></code>
would be an error.</p>
<p>In R, all reduction operations implement an alternative semantics,
activated by passing a special argument (<code class="docutils literal notranslate"><span class="pre">na.rm=TRUE</span></code> in R).
<code class="docutils literal notranslate"><span class="pre">sum(a)</span></code> means “give me the sum of all the
values” (which is NA if some of the values are NA);
<code class="docutils literal notranslate"><span class="pre">sum(a,</span> <span class="pre">na.rm=True)</span></code> means “give me the sum of all the non-NA
values”.</p>
</dd>
</dl>
</section>
<section id="other-prior-art">
<h3>Other prior art<a class="headerlink" href="#other-prior-art" title="Link to this heading">#</a></h3>
<p>Once we move beyond the “statistical missing data” case, the correct
behavior for missing data becomes less clearly defined. There are many
cases where specific elements are singled out to be treated specially
or excluded from computations, and these could often be conceptualized
as involving ‘missing data’ in some sense.</p>
<p>In image processing, it’s common to use a single image together with
one or more boolean masks to e.g. composite subsets of an image. As
Joe Harrington pointed out on the list, in the context of processing
astronomical images, it’s also common to generalize to a
floating-point valued mask, or alpha channel, to indicate degrees of
“missingness”. We think this is out of scope for the present design,
but it is an important use case, and ideally NumPy should support
natural ways of manipulating such data.</p>
<p>After R, numpy.ma is probably the most mature source of
experience on missing-data-related APIs. Its design is quite different
from R; it uses different semantics – reductions skip masked values
by default and NaNs convert to masked – and it uses a different
storage strategy via a separate mask. While it seems to be generally
considered sub-optimal for general use, it’s hard to pin down whether
this is because the API is immature but basically good, or the API
is fundamentally broken, or the API is great but the code should be
faster, or what. We looked at some of those users to try and get a
better idea.</p>
<p>Matplotlib is perhaps the best known package to rely on numpy.ma. It
seems to use it in two ways. One is as a way for users to indicate
what data is missing when passing it to be graphed. (Other ways are
also supported, e.g., passing in NaN values gives the same result.) In
this regard, matplotlib treats np.ma.masked and NaN values in the same way
that R’s plotting routines handle NA and NaN values. For these purposes,
matplotlib doesn’t really care what semantics or storage strategy is
used for missing data.</p>
<p>Internally, matplotlib uses numpy.ma arrays to store and pass around
separately computed boolean masks containing ‘validity’ information
for each input array in a cheap and non-destructive fashion. Mark’s
impression from some shallow code review is that mostly it works
directly with the data and mask attributes of the masked arrays,
not extensively using the particular computational semantics of
numpy.ma. So, for this usage they do rely on the non-destructive
mask-based storage, but this doesn’t say much about what semantics
are needed.</p>
<p>Paul Hobson <a class="reference external" href="https://mail.scipy.org/pipermail/numpy-discussion/2012-April/061743.html">posted some code</a> on the list that uses numpy.ma for
storing arrays of contaminant concentration measurements. Here the
mask indicates whether the corresponding number represents an actual
measurement, or just the estimated detection limit for a concentration
which was too small to detect. Nathaniel’s impression from reading
through this code is that it also mostly uses the .data and .mask
attributes in preference to performing operations on the MaskedArray
directly.</p>
<p>So, these examples make it clear that there is demand for a convenient
way to keep a data array and a mask array (or even a floating point
array) bundled up together and “aligned”. But they don’t tell us much
about what semantics the resulting object should have with respect to
ufuncs and friends.</p>
</section>
</section>
<section id="semantics-storage-api-oh-my">
<h2>Semantics, storage, API, oh my!<a class="headerlink" href="#semantics-storage-api-oh-my" title="Link to this heading">#</a></h2>
<p>We think it’s useful to draw a clear line between use cases,
semantics, and storage. Use cases are situations that users encounter,
regardless of what NumPy does; they’re the focus of the previous
section. When we say <em>semantics</em>, we mean the result of different
operations as viewed from the Python level without regard to the
underlying implementation.</p>
<p><em>NA semantics</em> are the ones described above and used by R:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="n">NA</span> <span class="o">=</span> <span class="n">NA</span>
<span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">NA</span><span class="p">])</span> <span class="o">=</span> <span class="n">NA</span>
<span class="n">NA</span> <span class="o">|</span> <span class="kc">False</span> <span class="o">=</span> <span class="n">NA</span>
<span class="n">NA</span> <span class="o">|</span> <span class="kc">True</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">na.rm=TRUE</span></code> or <code class="docutils literal notranslate"><span class="pre">skipNA=True</span></code>, this switches to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="o">+</span> <span class="n">NA</span> <span class="o">=</span> <span class="n">illegal</span> <span class="c1"># in R, only reductions take na.rm argument</span>
<span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">NA</span><span class="p">],</span> <span class="n">skipNA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>There’s also been discussion of what we’ll call <em>ignore
semantics</em>. These are somewhat underdefined:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">IGNORED</span><span class="p">])</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># Several options here:</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">IGNORED</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">#  or</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">IGNORED</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">leaves</span> <span class="n">output</span> <span class="n">array</span> <span class="n">untouched</span><span class="o">&gt;</span>
<span class="c1">#  or</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">IGNORED</span> <span class="o">=</span> <span class="n">IGNORED</span>
</pre></div>
</div>
<p>The numpy.ma semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">masked</span><span class="p">])</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">masked</span> <span class="o">=</span> <span class="n">masked</span>
</pre></div>
</div>
<p>If either NA or ignore semantics are implemented with masks, then there
is a choice of what should be done to the value in the storage
for an array element which gets assigned a missing value. Three
possibilities are:</p>
<ul class="simple">
<li><p>Leave that memory untouched (the choice made in the NEP).</p></li>
<li><p>Do the calculation with the values independently of the mask
(perhaps the most useful option for Paul Hobson’s use-case above).</p></li>
<li><p>Copy whatever value is stored behind the input missing value into
the output (this is what numpy.ma does. Even that is ambiguous in
the case of <code class="docutils literal notranslate"><span class="pre">masked</span> <span class="pre">+</span> <span class="pre">masked</span></code> – in this case numpy.ma copies the
value stored behind the leftmost masked value).</p></li>
</ul>
<p>When we talk about <em>storage</em>, we mean the debate about whether missing
values should be represented by designating a particular value of the
underlying data-type (the <em>bitpattern dtype</em> option, as used in R), or
by using a separate <em>mask</em> stored alongside the data itself.</p>
<p>For mask-based storage, there is also an important question about what
the API looks like for accessing the mask, modifying the mask, and
“peeking behind” the mask.</p>
</section>
<section id="designs-that-have-been-proposed">
<h2>Designs that have been proposed<a class="headerlink" href="#designs-that-have-been-proposed" title="Link to this heading">#</a></h2>
<p>One option is to just copy R, by implementing a mechanism whereby
dtypes can arrange for certain bitpatterns to be given NA semantics.</p>
<p>One option is to copy numpy.ma closely, but with a more optimized
implementation. (Or to simply optimize the existing implementation.)</p>
<p>One option is that described in <cite>NEP12</cite>, for which an implementation
of mask-based missing data exists. This system is roughly:</p>
<ul class="simple">
<li><p>There is both bitpattern and mask-based missing data, and both
have identical interoperable NA semantics.</p></li>
<li><p>Masks are modified by assigning np.NA or values to array elements.
The way to peek behind the mask or to unmask values is to keep a
view of the array that shares the data pointer but not the mask pointer.</p></li>
<li><p>Mark would like to add a way to access and manipulate the mask more
directly, to be used in addition to this view-based API.</p></li>
<li><p>If an array has both a bitpattern dtype and a mask, then assigning
np.NA writes to the mask, rather than to the array itself. Writing
a bitpattern NA to an array which supports both requires accessing
the data by “peeking under the mask”.</p></li>
</ul>
<p>Another option is that described in <cite>NEP24</cite>, which is to implement
bitpattern dtypes with NA semantics for the “statistical missing data”
use case, and to also implement a totally independent API for masked
arrays with ignore semantics and all mask manipulation done explicitly
through a .mask attribute.</p>
<p>Another option would be to define a minimalist aligned array container
that holds multiple arrays and that can be used to pass them around
together. It would support indexing (to help with the common problem
of wanting to subset several arrays together without their becoming
unaligned), but all arithmetic etc. would be done by accessing the
underlying arrays directly via attributes. The “prior art” discussion
above suggests that something like this holding a .data and a .mask
array might actually be solve a number of people’s problems without
requiring any major architectural changes to NumPy. This is similar to
a structured array, but with each field in a separately stored array
instead of packed together.</p>
<p>Several people have suggested that there should be a single system
that has multiple missing values that each have different semantics,
e.g., a MISSING value that has NA semantics, and a separate IGNORED
value that has ignored semantics.</p>
<p>None of these options are necessarily exclusive.</p>
</section>
<section id="the-debate">
<h2>The debate<a class="headerlink" href="#the-debate" title="Link to this heading">#</a></h2>
<p>We both are dubious of using ignored semantics as a default missing
data behavior. <strong>Nathaniel</strong> likes NA semantics because he is most
interested in the “statistical missing data” use case, and NA semantics
are exactly right for that. <strong>Mark</strong> isn’t as interested in that use
case in particular, but he likes the NA computational abstraction
because it is unambiguous and well-defined in all cases, and has a
lot of existing experience to draw from.</p>
<p>What <strong>Nathaniel</strong> thinks, overall:</p>
<ul class="simple">
<li><p>The “statistical missing data” use case is clear and compelling; the
other use cases certainly deserve our attention, but it’s hard to say what
they <em>are</em> exactly yet, or even if the best way to support them is
by extending the ndarray object.</p></li>
<li><p>The “statistical missing data” use case is best served by an R-style
system that uses bitpattern storage to implement NA semantics. The
main advantage of bitpattern storage for this use case is that it
avoids the extra memory and speed overhead of storing and checking a
mask (especially for the common case of floating point data, where
some tricks with NaNs allow us to effectively hardware-accelerate
most NA operations). These concerns alone appears to make a
mask-based implementation unacceptable to many NA users,
particularly in areas like neuroscience (where memory is tight) or
financial modeling (where milliseconds are critical). In addition,
the bit-pattern approach is less confusing conceptually (e.g.,
assignment really is just assignment, no magic going on behind the
curtain), and it’s possible to have in-memory compatibility with R
for inter-language calls via rpy2.  The main disadvantage of the
bitpattern approach is the need to give up a value to represent NA,
but this is not an issue for the most important data types (float,
bool, strings, enums, objects); really, only integers are
affected. And even for integers, giving up a value doesn’t really
matter for statistical problems. (Occupy Wall Street
notwithstanding, no-one’s income is 2**63 - 1. And if it were, we’d
be switching to floats anyway to avoid overflow.)</p></li>
<li><p>Adding new dtypes requires some cooperation with the ufunc and
casting machinery, but doesn’t require any architectural changes or
violations of NumPy’s current orthogonality.</p></li>
<li><p>His impression from the mailing list discussion, esp. the <a class="reference external" href="http://thread.gmane.org/gmane.comp.python.numeric.general/46704">“what can
we agree on?” thread</a>, is that many numpy.ma users specifically
like the combination of masked storage, the mask being easily
accessible through the API, and ignored semantics. He could be
wrong, of course. But he cannot remember seeing anybody besides Mark
advocate for the specific combination of masked storage and NA
semantics, which makes him nervous.</p>
</li>
<li><p>Also, he personally is not very happy with the idea of having two
storage implementations that are almost-but-not-quite identical at
the Python level. While there likely are people who would like to
temporarily pretend that certain data is “statistically missing
data” without making a copy of their array, it’s not at all clear
that they outnumber the people who would like to use bitpatterns and
masks simultaneously for distinct purposes. And honestly he’d like
to be able to just ignore masks if he wants and stick to
bitpatterns, which isn’t possible if they’re coupled together
tightly in the API.  So he would say the jury is still very much out
on whether this aspect of the NEP design is an advantage or a
disadvantage. (Certainly he’s never heard of any R users complaining
that they really wish they had an option of making a different
trade-off here.)</p></li>
<li><p>R’s NA support is a <a class="reference external" href="http://www.sr.bham.ac.uk/~ajrs/R/why_R.html">headline feature</a> and its target audience
consider it a compelling advantage over other platforms like Matlab
or Python. Working with statistical missing data is very painful
without platform support.</p>
</li>
<li><p>By comparison, we clearly have much more uncertainty about the use
cases that require a mask-based implementation, and it doesn’t seem
like people will suffer too badly if they are forced for now to
settle for using NumPy’s excellent mask-based indexing, the new
where= support, and even numpy.ma.</p></li>
<li><p>Therefore, bitpatterns with NA semantics seem to meet the criteria
of making a large class of users happy, in an elegant way, that fits
into the original design, and where we can have reasonable certainty
that we understand the problem and use cases well enough that we’ll
be happy with them in the long run. But no mask-based storage
proposal does, yet.</p></li>
</ul>
<p>What <strong>Mark</strong> thinks, overall:</p>
<ul class="simple">
<li><p>The idea of using NA semantics by default for missing data, inspired
by the “statistical missing data” problem, is better than all the
other default behaviors which were considered. This applies equally
to the bitpattern and the masked approach.</p></li>
<li><p>For NA-style functionality to get proper support by all NumPy
features and eventually all third-party libraries, it needs to be
in the core. How to correctly and efficiently handle missing data
differs by algorithm, and if thinking about it is required to fully
support NumPy, NA support will be broader and higher quality.</p></li>
<li><p>At the same time, providing two different missing data interfaces,
one for masks and one for bitpatterns, requires NumPy developers
and third-party NumPy plugin developers to separately consider the
question of what to do in either case, and do two additional
implementations of their code. This complicates their job,
and could lead to inconsistent support for missing data.</p></li>
<li><p>Providing the ability to work with both masks and bitpatterns through
the same C and Python programming interface makes missing data support
cleanly orthogonal with all other NumPy features.</p></li>
<li><p>There are many trade-offs of memory usage, performance, correctness, and
flexibility between masks and bitpatterns. Providing support for both
approaches allows users of NumPy to choose the approach which is
most compatible with their way of thinking, or has characteristics
which best match their use-case. Providing them through the same
interface further allows them to try both with minimal effort, and
choose the one which performs better or uses the least memory for
their programs.</p></li>
<li><p>Memory Usage</p>
<ul>
<li><p>With bitpatterns, less memory is used for storing a single array
containing some NAs.</p></li>
<li><p>With masks, less memory is used for storing multiple arrays that
are identical except for the location of their NAs. (In this case a
single data array can be re-used with multiple mask arrays;
bitpattern NAs would need to copy the whole data array.)</p></li>
</ul>
</li>
<li><p>Performance</p>
<ul>
<li><p>With bitpatterns, the floating point type can use native hardware
operations, with nearly correct behavior. For fully correct floating
point behavior and with other types, code must be written which
specially tests for equality with the missing-data bitpattern.</p></li>
<li><p>With masks, there is always the overhead of accessing mask memory
and testing its truth value. The implementation that currently exists
has no performance tuning, so it is only good to judge a minimum
performance level. Optimal mask-based code is in general going to
be slower than optimal bitpattern-based code.</p></li>
</ul>
</li>
<li><p>Correctness</p>
<ul>
<li><p>Bitpattern integer types must sacrifice a valid value to represent NA.
For larger integer types, there are arguments that this is ok, but for
8-bit types there is no reasonable choice. In the floating point case,
if the performance of native floating point operations is chosen,
there is a small inconsistency that NaN+NA and NA+NaN are different.</p></li>
<li><p>With masks, it works correctly in all cases.</p></li>
</ul>
</li>
<li><p>Generality</p>
<ul>
<li><p>The bitpattern approach can work in a fully general way only when
there is a specific value which can be given up from the
data type. For IEEE floating point, a NaN is an obvious choice,
and for booleans represented as a byte, there are plenty of choices.
For integers, a valid value must be sacrificed to use this approach.
Third-party dtypes which plug into NumPy will also have to
make a bitpattern choice to support this system, something which
may not always be possible.</p></li>
<li><p>The mask approach works universally with all data types.</p></li>
</ul>
</li>
</ul>
</section>
<section id="recommendations-for-moving-forward">
<h2>Recommendations for moving forward<a class="headerlink" href="#recommendations-for-moving-forward" title="Link to this heading">#</a></h2>
<p><strong>Nathaniel</strong> thinks we should:</p>
<ul class="simple">
<li><p>Go ahead and implement bitpattern NAs.</p></li>
<li><p><em>Don’t</em> implement masked arrays in the core – or at least, not
yet. Instead, we should focus on figuring out how to implement them
out-of-core, so that people can try out different approaches without
us committing to any one approach. And so new prototypes can be
released more quickly than the NumPy release cycle. And anyway,
we’re going to have to figure out how to experiment with such
changes out-of-core if NumPy is to continue to evolve without
forking – might as well do it now. The existing code can live in
the main branch, be disabled, or live its own branch – it’ll still be there
once we know what we’re doing.</p></li>
</ul>
<p><strong>Mark</strong> thinks we should:</p>
<ul class="simple">
<li><p>The existing code should remain as is, with a global run-time experimental
flag added which disables NA support by default.</p></li>
</ul>
<p>A more detailed rationale for this recommendation is:</p>
<ul class="simple">
<li><p>A solid preliminary NA-mask implementation is currently in NumPy
main. This implementation has been extensively tested
against scipy and other third-party packages, and has been in main
in a stable state for a significant amount of time.</p></li>
<li><p>This implementation integrates deeply with the core, providing an
interface which is usable in the same way R’s NA support is. It
provides a compelling, user-friendly answer to R’s NA support.</p></li>
<li><p>The missing data NEP provides a plan for adding bitpattern-based
dtype support of NAs, which will operate through the same interface
but allow for the same performance/correctness tradeoffs that R has made.</p></li>
<li><p>Making it very easy for users to try out this implementation, which
has reasonable feature coverage and performance characteristics, is
the best way to get more concrete feedback about how NumPy’s missing
data support should look.</p></li>
</ul>
<p>Because of its preliminary state, the existing implementation is marked
as experimental in the NumPy documentation. It would be good for this
to remain marked as experimental until it is more fleshed out, for
example supporting struct and array dtypes and with a fuller set of
NumPy operations.</p>
<p>I think the code should stay as it is, except to add a run-time global
NumPy flag, perhaps numpy.experimental.maskna, which defaults to
False and can be toggled to True. In its default state, any NA feature
usage would raise an “ExperimentalError” exception, a measure which
would prevent it from being accidentally used and communicate its
experimental status very clearly.</p>
<p>The <a class="reference external" href="http://thread.gmane.org/gmane.comp.python.numeric.general/49485&gt;">ABI issues</a> seem very tricky to deal with effectively in the 1.x
series of releases, but I believe that with proper implementation-hiding
in a 2.0 release, evolving the software to support various other
ABI ideas that have been discussed is feasible. This is the approach
I like best.</p>
<p><strong>Nathaniel</strong> notes in response that he doesn’t really have any
objection to shipping experimental APIs in the main numpy distribution
<em>if</em> we’re careful to make sure that they don’t “leak out” in a way
that leaves us stuck with them. And in principle some sort of “this
violates your warranty” global flag could be a way to do that. (In
fact, this might also be a useful strategy for the kinds of changes
that he favors, of adding minimal hooks to enable us to build
prototypes more easily – we could have some “rapid prototyping only”
hooks that let prototype hacks get deeper access to NumPy’s internals
than we were otherwise ready to support.)</p>
<p>But, he wants to point out two things. First, it seems like we still
have fundamental questions to answer about the NEP design, like
whether masks should have NA semantics or ignore semantics, and there
are already plans to majorly change how NEP masks are exposed and
accessed. So he isn’t sure what we’ll learn by asking for feedback on
the NEP code in its current state.</p>
<p>And second, given the concerns about their causing (minor) ABI issues,
it’s not clear that we could really prevent them from leaking out. (He
looks forward to 2.0 too, but we’re not there yet.) So maybe it would
be better if they weren’t present in the C API at all, and the hoops
required for testers were instead something like, ‘we have included a
hacky pure-Python prototype accessible by typing “import
numpy.experimental.donttrythisathome.NEP” and would welcome feedback’?</p>
<p>If so, then he should mention that he did implement a horribly klugy,
pure Python implementation of the NEP API that works with NumPy
1.6.1. This was mostly as an experiment to see how possible such
prototyping was and to test out a possible ufunc override mechanism,
but if there’s interest, the module is available here:
<a class="github reference external" href="https://github.com/njsmith/numpyNEP">njsmith/numpyNEP</a></p>
<p>It passes the maskna test-suite, with some minor issues described
in a big comment at the top.</p>
<p><strong>Mark</strong> responds:</p>
<p>I agree that it’s important to be careful when adding new
features to NumPy, but I also believe it is essential that the project
have forward development momentum. A project like NumPy requires
developers to write code for advancement to occur, and obstacles
that impede the writing of code discourage existing developers
from contributing more, and potentially scare away developers
who are thinking about joining in.</p>
<p>All software projects, both open source and closed source, must
balance between short-term practicality and long-term planning.
In the case of the missing data development, there was a short-term
resource commitment to tackle this problem, which is quite immense
in scope. If there isn’t a high likelihood of getting a contribution
into NumPy that concretely advances towards a solution, I expect
that individuals and companies interested in doing such work will
have a much harder time justifying a commitment of their resources.
For a project which is core to so many other libraries, only
relying on the good will of selfless volunteers would mean that
NumPy could more easily be overtaken by another project.</p>
<p>In the case of the existing NA contribution at issue, how we resolve
this disagreement represents a decision about how NumPy’s
developers, contributors, and users should interact. If we create
a document describing a dispute resolution process, how do we
design it so that it doesn’t introduce a large burden and excessive
uncertainty on developers that could prevent them from productively
contributing code?</p>
<p>If we go this route of writing up a decision process which includes
such a dispute resolution mechanism, I think the meat of it should
be a roadmap that potential contributors and developers can follow
to gain influence over NumPy. NumPy development needs broad support
beyond code contributions, and tying influence in the project to
contributions seems to me like it would be a good way to encourage
people to take on tasks like bug triaging/management, continuous
integration/build server administration, and the myriad other
tasks that help satisfy the project’s needs. No specific meritocratic,
democratic, consensus-striving system will satisfy everyone, but the
vigour of the discussions around governance and process indicate that
something at least a little bit more formal than the current status
quo is necessary.</p>
<p>In conclusion, I would like the NumPy project to prioritize movement
towards a more flexible and modular ABI/API, balanced with strong
backwards-compatibility constraints and feature additions that
individuals, universities, and companies want to contribute.
I do not believe keeping the NA code in 1.7 as it is, with the small
additional measure of requiring it to be enabled by an experimental
flag, poses a risk of long-term ABI troubles. The greater risk I see
is a continuing lack of developers contributing to the project,
and I believe backing out this code because these worries would create a
risk of reducing developer contribution.</p>
<section id="references-and-footnotes">
<h3>References and footnotes<a class="headerlink" href="#references-and-footnotes" title="Link to this heading">#</a></h3>
<p><a class="reference internal" href="nep-0012-missing-data.html#nep12"><span class="std std-ref">NEP 12 — Missing data functionality in NumPy</span></a> describes Mark’s NA-semantics/mask implementation/view based mask
handling API.</p>
<p><a class="reference internal" href="nep-0024-missing-data-2.html#nep24"><span class="std std-ref">NEP 24 — Missing data functionality - alternative 1 to NEP 12</span></a> (“the alterNEP”) was Nathaniel’s initial attempt at separating MISSING
and IGNORED handling into bit-patterns versus masks, though there’s a bunch
he would change about the proposal at this point.</p>
<p><a class="reference internal" href="nep-0025-missing-data-3.html#nep25"><span class="std std-ref">NEP 25 — NA support via special dtypes</span></a> (“miniNEP 2”) was a later attempt by Nathaniel to sketch out an
implementation strategy for NA dtypes.</p>
<p>A further discussion overview page can be found at:
<a class="github reference external" href="https://github.com/njsmith/numpy/wiki/NA-discussion-status">njsmith/numpy</a></p>
</section>
<section id="copyright">
<h3>Copyright<a class="headerlink" href="#copyright" title="Link to this heading">#</a></h3>
<p>This document has been placed in the public domain.</p>
</section>
</section>
</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-numpy-developers-problem">The NumPy developers’ problem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prior-art">Prior art</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#statistical-missing-data">“Statistical missing data”</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#na-semantics">NA semantics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#other-prior-art">Other prior art</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#semantics-storage-api-oh-my">Semantics, storage, API, oh my!</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#designs-that-have-been-proposed">Designs that have been proposed</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-debate">The debate</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#recommendations-for-moving-forward">Recommendations for moving forward</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-footnotes">References and footnotes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#copyright">Copyright</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2017-2025, NumPy Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>