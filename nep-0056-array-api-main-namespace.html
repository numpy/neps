
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>NEP 56 — Array API standard support in NumPy’s main namespace &#8212; NumPy Enhancement Proposals</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="_static/documentation_options.js?v=7f41d439"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'nep-0056-array-api-main-namespace';</script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deferred and Superseded NEPs" href="deferred.html" />
    <link rel="prev" title="NEP 55 — Add a UTF-8 variable-width string DType to NumPy" href="nep-0055-string_dtype.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
    <meta name="docbuild:last-update" content="Jan 16, 2025"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="content.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/numpylogo.svg" class="logo__image only-light" alt="NumPy Enhancement Proposals - Home"/>
    <img src="_static/numpylogo.svg" class="logo__image only-dark pst-js-only" alt="NumPy Enhancement Proposals - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Index
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="scope.html">
    The Scope of NumPy
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Current roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wish list
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">
    Wishlist
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/numpy/numpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="scope.html">The Scope of NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="roadmap.html">Current roadmap</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/numpy/numpy/issues?q=is%3Aopen+is%3Aissue+label%3A%2223+-+Wish+List%22">Wish list</a></li>
</ul>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="meta.html">Meta-NEPs (NEPs about NEPs or active Processes)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0000.html">NEP 0 — Purpose and process</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0023-backwards-compatibility.html">NEP 23 — Backwards compatibility and deprecation policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0036-fair-play.html">NEP 36 — Fair play</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0045-c_style_guide.html">NEP 45 — C style guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0046-sponsorship-guidelines.html">NEP 46 — NumPy sponsorship guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0048-spending-project-funds.html">NEP 48 — Spending NumPy project funds</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-template.html">NEP X — Template and instructions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="provisional.html">Provisional NEPs (provisionally accepted; interface may change)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="simple">
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="accepted.html">Accepted NEPs (implementation in progress)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0041-improved-dtype-support.html">NEP 41 — First step towards a new datatype system</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0042-new-dtypes.html">NEP 42 — New and extensible DTypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0044-restructuring-numpy-docs.html">NEP 44 — Restructuring the NumPy documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0051-scalar-representation.html">NEP 51 — Changing the representation of NumPy scalars</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="open.html">Open NEPs (under consideration)</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0043-extensible-ufuncs.html">NEP 43 — Enhancing the extensibility of UFuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0053-c-abi-evolution.html">NEP 53 — Evolving the NumPy C-API for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0054-simd-cpp-highway.html">NEP 54 — SIMD infrastructure evolution: adopting Google Highway when moving to C++?</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="finished.html">Finished NEPs</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nep-0001-npy-format.html">NEP 1 — A simple file format for NumPy arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0005-generalized-ufuncs.html">NEP 5 — Generalized universal functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0007-datetime-proposal.html">NEP 7 — A proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0010-new-iterator-ufunc.html">NEP 10 — Optimizing iterator/UFunc performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0013-ufunc-overrides.html">NEP 13 — A mechanism for overriding Ufuncs</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0014-dropping-python2.7-proposal.html">NEP 14 — Plan for dropping Python 2.7 support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0015-merge-multiarray-umath.html">NEP 15 — Merging multiarray and umath</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0018-array-function-protocol.html">NEP 18 — A dispatch mechanism for NumPy's high level array functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0019-rng-policy.html">NEP 19 — Random number generator policy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0020-gufunc-signature-enhancement.html">NEP 20 — Expansion of generalized universal function signatures</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0022-ndarray-duck-typing-overview.html">NEP 22 — Duck typing for NumPy arrays – high level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0027-zero-rank-arrarys.html">NEP 27 — Zero rank arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0028-website-redesign.html">NEP 28 — numpy.org website redesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0029-deprecation_policy.html">NEP 29 — Recommend Python and NumPy version support as a community policy standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0032-remove-financial-functions.html">NEP 32 — Remove the financial functions from NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0034-infer-dtype-is-object.html">NEP 34 — Disallow inferring ``dtype=object`` from sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0035-array-creation-dispatch-with-array-function.html">NEP 35 — Array creation dispatching with __array_function__</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0038-SIMD-optimizations.html">NEP 38 — Using SIMD optimization instructions for performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0040-legacy-datatype-impl.html">NEP 40 — Legacy datatype implementation in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0049.html">NEP 49 — Data allocation strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0050-scalar-promotion.html">NEP 50 — Promotion rules for Python scalars</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0052-python-api-cleanup.html">NEP 52 — Python API cleanup for NumPy 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0055-string_dtype.html">NEP 55 — Add a UTF-8 variable-width string DType to NumPy</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">NEP 56 — Array API standard support in NumPy's main namespace</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="deferred.html">Deferred and Superseded NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0002-warnfix.html">NEP 2 — A proposal to build numpy without warning with a big set of warning flags</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0003-math_config_clean.html">NEP 3 — Cleaning the math configuration of numpy.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0004-datetime-proposal3.html">NEP 4 — A (third) proposal for implementing some date/time types in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0006-newbugtracker.html">NEP 6 — Replacing Trac with a different bug tracker</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0008-groupby_additions.html">NEP 8 — A proposal for adding groupby functionality to NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0009-structured_array_extensions.html">NEP 9 — Structured array extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0011-deferred-ufunc-evaluation.html">NEP 11 — Deferred UFunc evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0012-missing-data.html">NEP 12 — Missing data functionality in NumPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0021-advanced-indexing.html">NEP 21 — Simplified and explicit advanced indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0024-missing-data-2.html">NEP 24 — Missing data functionality - alternative 1 to NEP 12</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0025-missing-data-3.html">NEP 25 — NA support via special dtypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0026-missing-data-summary.html">NEP 26 — Summary of missing data NEPs and discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0030-duck-array-protocol.html">NEP 30 — Duck typing for NumPy arrays - implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0031-uarray.html">NEP 31 — Context-local and global overrides of the NumPy API</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0037-array-module.html">NEP 37 — A dispatch protocol for NumPy-like modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0047-array-api-standard.html">NEP 47 — Adopting the array API standard</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="rejected.html">Rejected and Withdrawn NEPs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="nep-0016-abstract-array.html">NEP 16 — An abstract base class for identifying "duck arrays"</a></li>
<li class="toctree-l2"><a class="reference internal" href="nep-0017-split-out-maskedarray.html">NEP 17 — Split out masked arrays</a></li>
</ul>
</details></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="content.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Roadmap &amp; NumPy enhancement proposals</a></li>
    
    
    <li class="breadcrumb-item"><a href="finished.html" class="nav-link">Finished NEPs</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">NEP 56 — Array API standard support in NumPy’s main namespace</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="nep-56-array-api-standard-support-in-numpy-s-main-namespace">
<span id="nep56"></span><h1>NEP 56 — Array API standard support in NumPy’s main namespace<a class="headerlink" href="#nep-56-array-api-standard-support-in-numpy-s-main-namespace" title="Link to this heading">#</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Ralf Gommers &lt;<a class="reference external" href="mailto:ralf&#46;gommers&#37;&#52;&#48;gmail&#46;com">ralf<span>&#46;</span>gommers<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Author<span class="colon">:</span></dt>
<dd class="field-even"><p>Mateusz Sokół &lt;<a class="reference external" href="mailto:msokol&#37;&#52;&#48;quansight&#46;com">msokol<span>&#64;</span>quansight<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nathan Goldbaum &lt;<a class="reference external" href="mailto:ngoldbaum&#37;&#52;&#48;quansight&#46;com">ngoldbaum<span>&#64;</span>quansight<span>&#46;</span>com</a>&gt;</p>
</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><p>Final</p>
</dd>
<dt class="field-odd">Replaces<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="nep-0030-duck-array-protocol.html#nep30"><span class="std std-ref">NEP 30 — Duck typing for NumPy arrays - implementation</span></a>, <a class="reference internal" href="nep-0031-uarray.html#nep31"><span class="std std-ref">NEP 31 — Context-local and global overrides of the NumPy API</span></a>, <a class="reference internal" href="nep-0037-array-module.html#nep37"><span class="std std-ref">NEP 37 — A dispatch protocol for NumPy-like modules</span></a>, <a class="reference internal" href="nep-0047-array-api-standard.html#nep47"><span class="std std-ref">NEP 47 — Adopting the array API standard</span></a></p>
</dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><p>Standards Track</p>
</dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd"><p>2023-12-19</p>
</dd>
<dt class="field-even">Resolution<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://mail.python.org/archives/list/numpy-discussion&#64;python.org/message/Z6AA5CL47NHBNEPTFWYOTSUVSRDGHYPN/">https://mail.python.org/archives/list/numpy-discussion&#64;python.org/message/Z6AA5CL47NHBNEPTFWYOTSUVSRDGHYPN/</a></p>
</dd>
</dl>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Link to this heading">#</a></h2>
<p>This NEP proposes adding nearly full support for the 2022.12 version of the
array API standard in NumPy’s main namespace for the 2.0 release.</p>
<p>Adoption in the main namespace has a number of advantages; most importantly for
libraries that depend on NumPy and want to start supporting other array
libraries. SciPy and scikit-learn are two prominent libraries already moving
along this path. The need to support the array API standard in the main
namespace draws from lessons learned by those libraries and the experimental
<code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code> implementation with a different array object.
There will also be benefits for other array libraries, JIT compilers like Numba,
and for end users who may have an easier time switching between different array
libraries.</p>
</section>
<section id="motivation-and-scope">
<h2>Motivation and scope<a class="headerlink" href="#motivation-and-scope" title="Link to this heading">#</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The main changes proposed in this NEP were presented in the NumPy 2.0
Developer Meeting in April 2023 (see <a class="reference external" href="https://github.com/numpy/archive/blob/main/2.0_developer_meeting/NumPy_2.0_devmeeting_array_API_adoption.pdf">here</a>
for presentations from that meeting) and given a thumbs up there. The
majority of the implementation work for NumPy 2.0 has already been merged.
For the rest, PRs are ready - those are mainly the items that are specific
to array API support and we’d probably not consider for inclusion in NumPy
without that context. This NEP will focus on those APIs and PRs in a bit
more detail.</p>
</div>
<p><a class="reference internal" href="nep-0047-array-api-standard.html#nep47"><span class="std std-ref">NEP 47 — Adopting the array API standard</span></a> contains the motivation for adding array API support to NumPy.
This NEP expands on and supersedes NEP 47. The main reason NEP 47 aimed for a
separate <code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code> submodule rather than the main namespace is that
casting rules differed too much. With value-based casting being removed
(<a class="reference internal" href="nep-0050-scalar-promotion.html#nep50"><span class="std std-ref">NEP 50 — Promotion rules for Python scalars</span></a>), that will be resolved in NumPy 2.0. Having NumPy be a superset
of the array API standard will be a significant improvement for code
portability to other libraries (CuPy, JAX, PyTorch, etc.) and thereby address
one of the top user requests from the 2020 NumPy user survey <a class="footnote-reference brackets" href="#id8" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> (GPU support).
See <a class="reference external" href="https://numpy.org/doc/1.26/reference/array_api.html#table-of-differences-between-numpy-array-api-and-numpy">the numpy.array_api API docs (1.26.x)</a>
for an overview of differences between it and the main namespace (note that the
“strictness” ones are not applicable).</p>
<p>Experiences with <code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code>, which is still marked as experimental,
have shown that the separate strict implementation and separate array object
are mostly good for testing purposes, but not for regular usage in downstream
libraries. Having support in the main namespace resolves this issue. Hence this
NEP supersedes NEP 47. The <code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code> module will be moved to a
standalone package, to facilitate easier updates not tied to a NumPy release
cycle.</p>
<p>Some of the key design rules from the array API standard (e.g., output dtypes
predictable from input dtypes, no polymorphic APIs with varying number of
returns controlled by keywords) will also be applied to NumPy functions that
are not part of the array API standard, because those design rules are now
understood to be good practice in general. Those two design rules in particular
make it easier for Numba and other JIT compilers to support NumPy or
NumPy-compatible APIs. We’ll note that making existing arguments
positional-only and keyword-only is a good idea for functions added to NumPy in
the future, but will not be done for existing functions since each such change
is a backwards compatibility break and it’s not necessary for writing code that
is portable across libraries supporting the standard. An additional reason to
apply those design rules to all functions in the main namespace now is that it
then becomes much easier to deal with potential standardization of new
functions already present in NumPy - those could otherwise be blocked or forced
to use alternative function names due to the need for backwards compatibility.</p>
<p>It is important that new functions added to the main namespace integrate well
with the rest of NumPy. So they should for example follow broadcasting and
other rules as expected, and work with all NumPy’s dtypes rather than only the
ones in the standard. The same goes for backwards-incompatible changes (e.g.,
linear algebra functions need to all support batching in the same way, and
consider the last two axes as matrices). As a result, NumPy should become more
rather than less consistent.</p>
<p>Here are what we see as the main expected benefits and costs of the complete
set of proposed changes:</p>
<p>Benefits:</p>
<ul class="simple">
<li><p>It will enable array-consuming libraries (the likes of SciPy and
scikit-learn, as well as smaller libraries higher up the stack) to implement
support for multiple array libraries,</p></li>
<li><p>It will remove the “having to make a choice between the NumPy API and the
array API standard” issue for other array libraries when choosing what API
to implement,</p></li>
<li><p>Easier for CuPy, JAX, PyTorch, Dask, Numba, and other such libraries and
compilers to match or support NumPy, through providing a more well-defined
and minimal API surface to target, as well as through resolving some
differences that were caused by Numpy semantics that were hard to support in
JIT compilers,</p></li>
<li><p>A few new features that have benefits independent of the standard: adding
<code class="docutils literal notranslate"><span class="pre">matrix_transpose</span></code> and <code class="docutils literal notranslate"><span class="pre">ndarray.mT</span></code>, adding <code class="docutils literal notranslate"><span class="pre">vecdot</span></code>, introducing
<code class="docutils literal notranslate"><span class="pre">matrix_norm</span></code>/<code class="docutils literal notranslate"><span class="pre">vector_norm</span></code> (they can be made gufuncs, vecdot already has
a PR making it one),</p></li>
<li><p>Closer correspondence between the APIs of NumPy and other array libraries
will lower the learning curve for end users when they switch from one array
library to another one,</p></li>
<li><p>The array API standard tends to have more consistent behavior than NumPy
itself has (in cases where there are differences between the two, see for
example the <a class="reference external" href="https://data-apis.org/array-api/2022.12/extensions/linear_algebra_functions.html#design-principles">linear algebra design principles</a>
and <a class="reference external" href="https://data-apis.org/array-api/2022.12/design_topics/data_dependent_output_shapes.html">data-dependent output shapes page</a>
in the standard),</p></li>
</ul>
<p>Costs:</p>
<ul class="simple">
<li><p>A number of backwards compatibility breaks (mostly minor, see the Backwards
compatibility section further down),</p></li>
<li><p>Expanding the size of the main namespace with about ~20 aliases (e.g.,
<code class="docutils literal notranslate"><span class="pre">acos</span></code> &amp; co. with C99 names aliasing <code class="docutils literal notranslate"><span class="pre">arccos</span></code> &amp; co.).</p></li>
</ul>
<p>Overall we believe that the benefits significantly outweigh the costs - and are
permanent, while the costs are largely temporary. In particular, the benefits
to array libraries and compilers that want to achieve compatibility with NumPy
are significant. And as a result, the long-term benefits for the PyData (or
scientific Python) ecosystem as a whole - because of downstream libraries being
able to support multiple array libraries much more easily - are
significant too. The number of breaking changes needed is fairly limited, and
the impact of those changes seems modest. Not painless, but we believe the
impact is smaller than the impact of other breaking changes in NumPy 2.0, and a
price worth paying.</p>
<p>In scope for this NEP are:</p>
<ul class="simple">
<li><p>Changes to NumPy’s Python API needed to support the 2022.12 version of the
array API standard, in the main namespace as well as <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> and
<code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code>,</p></li>
<li><p>Changes in the behavior of existing NumPy functions not (or not yet) present
in the array API standard, to align with key design principles of the
standard.</p></li>
</ul>
<p>Out of scope for this NEP are:</p>
<ul class="simple">
<li><p>Other changes to NumPy’s Python API unrelated to the array API standard,</p></li>
<li><p>Changes to NumPy’s C API.</p></li>
</ul>
<p>This NEP will supersede the following NEPs:</p>
<ul class="simple">
<li><p><a class="reference internal" href="nep-0030-duck-array-protocol.html#nep30"><span class="std std-ref">NEP 30 — Duck typing for NumPy arrays - implementation</span></a> (never implemented)</p></li>
<li><p><a class="reference internal" href="nep-0031-uarray.html#nep31"><span class="std std-ref">NEP 31 — Context-local and global overrides of the NumPy API</span></a> (never implemented)</p></li>
<li><p><a class="reference internal" href="nep-0037-array-module.html#nep37"><span class="std std-ref">NEP 37 — A dispatch protocol for NumPy-like modules</span></a> (never implemented; the <code class="docutils literal notranslate"><span class="pre">__array_module__</span></code> idea is basically
the same as <code class="docutils literal notranslate"><span class="pre">__array_namespace__</span></code>)</p></li>
<li><p><a class="reference internal" href="nep-0047-array-api-standard.html#nep47"><span class="std std-ref">NEP 47 — Adopting the array API standard</span></a> (implemented with an experimental label in <code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code>,
will be removed)</p></li>
</ul>
</section>
<section id="usage-and-impact">
<h2>Usage and impact<a class="headerlink" href="#usage-and-impact" title="Link to this heading">#</a></h2>
<p>We have several different types of users in mind: end users writing numerical
code, downstream packages that depend on NumPy who want to start supporting
multiple array libraries, and other array libraries and tools which aim to
implement NumPy-like or NumPy-compatible APIs.</p>
<p>The most prominent users who will benefit from array API support are probably
downstream libraries that want to start supporting CuPy, PyTorch, JAX, Dask, or
other such libraries. SciPy and scikit-learn are already fairly far along the
way of doing just that, and successfully support CuPy arrays and PyTorch
tensors in a small part of their own APIs (that support is still marked as
experimental).</p>
<p>The main principle they use is that they replace the regular
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code> with a utility function to retrieve the array library
namespace from the input array. They call it <code class="docutils literal notranslate"><span class="pre">xp</span></code>, which is effectively an
alias to <code class="docutils literal notranslate"><span class="pre">np</span></code> if the input is a NumPy array, <code class="docutils literal notranslate"><span class="pre">cupy</span></code> for a CuPy array,
<code class="docutils literal notranslate"><span class="pre">torch</span></code> for a PyTorch tensor. This <code class="docutils literal notranslate"><span class="pre">xp</span></code> then allows writing code that works
for all these libraries - because the array API standard is the common
denominator. As a concrete example, this code is taken from <code class="docutils literal notranslate"><span class="pre">scipy.cluster</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">vq_py</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">code_book</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Python version of vq algorithm&quot;&quot;&quot;</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">code_book</span><span class="p">)</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">as_xparray</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">code_book</span> <span class="o">=</span> <span class="n">as_xparray</span><span class="p">(</span><span class="n">code_book</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">code_book</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Observation and code_book should have the same rank&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[:,</span> <span class="n">xp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">code_book</span> <span class="o">=</span> <span class="n">code_book</span><span class="p">[:,</span> <span class="n">xp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Once `cdist` has array API support, this `xp.asarray` call can be removed</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">code_book</span><span class="p">))</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code</span><span class="p">,</span> <span class="n">min_dist</span>
</pre></div>
</div>
<p>It mostly looks like normal NumPy code, but will run with for example PyTorch
tensors as input and then return PyTorch tensors. There is a lot more to this
story of course then this basic example. These blog posts on scikit-learn <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
and SciPy’s <a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> experiences and impact (large performance gains in some cases
- <code class="docutils literal notranslate"><span class="pre">LinearDiscriminantAnalysis.fit</span></code> showed ~28x gain with PyTorch on GPU vs.
NumPy) paint a more complete picture.</p>
<p>For end users who are using NumPy directly, little changes aside from there
being fewer differences between NumPy and other libraries they may want to use
as well. This shortens their learning curve and makes it easier to switch
between NumPy and PyTorch/JAX/CuPy. In addition, they should benefit from
array-consuming libraries starting to support multiple array libraries, making
their experience of using a stack of Python packages for scientific computing
or data science more seamless.</p>
<p>Finally, for authors of other array libraries as well as tools like Numba,
API improvements which align NumPy with the array API standard will also save
them time. The design rules (<a class="footnote-reference brackets" href="#id7" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>), and in some cases new APIs like the
<code class="docutils literal notranslate"><span class="pre">unique_*</span></code> ones, are easier to implement on GPU and for JIT compilers as a
result of more predictable behavior.</p>
</section>
<section id="backward-compatibility">
<h2>Backward compatibility<a class="headerlink" href="#backward-compatibility" title="Link to this heading">#</a></h2>
<p>The changes that have a backwards compatibility impact fall into these
categories:</p>
<ol class="arabic simple">
<li><p>Raising errors for consistency/strictness in some places where NumPy now
allows more flexible behavior,</p></li>
<li><p>Dtypes of returned arrays for some element-wise functions and reductions,</p></li>
<li><p>Numerical behavior for a few tolerance keywords,</p></li>
<li><p>Functions moved to <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code> and supporting stacking/batching,</p></li>
<li><p>The semantics of the <code class="docutils literal notranslate"><span class="pre">copy</span></code> keyword in <code class="docutils literal notranslate"><span class="pre">asarray</span></code> and <code class="docutils literal notranslate"><span class="pre">array</span></code>,</p></li>
<li><p>Changes to <code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code> functionality.</p></li>
</ol>
<p><strong>Raising errors for consistency/strictness includes</strong>:</p>
<ol class="arabic simple">
<li><p>Making <code class="docutils literal notranslate"><span class="pre">.T</span></code> error for &gt;2 dimensions,</p></li>
<li><p>Making <code class="docutils literal notranslate"><span class="pre">cross</span></code> error on size-2 vectors (only size-3 vectors are supported),</p></li>
<li><p>Making <code class="docutils literal notranslate"><span class="pre">solve</span></code> error on ambiguous input (only accept <code class="docutils literal notranslate"><span class="pre">x2</span></code> as vector if <code class="docutils literal notranslate"><span class="pre">x2.ndim</span> <span class="pre">==</span> <span class="pre">1</span></code>),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">outer</span></code> raises rather than flattens on &gt;1-D inputs,</p></li>
</ol>
<p><em>We expect the impact of this category of changes to be small.</em></p>
<p><strong>Dtypes of returned arrays for some element-wise functions and reductions</strong>
includes functions where dtypes need to be preserved: <code class="docutils literal notranslate"><span class="pre">ceil</span></code>, <code class="docutils literal notranslate"><span class="pre">floor</span></code>, and
<code class="docutils literal notranslate"><span class="pre">trunc</span></code> will start returning arrays with the same integer dtypes if the input
has an integer dtype.</p>
<p><em>We expect the impact of this category of changes to be small.</em></p>
<p><strong>Changes in numerical behavior</strong> include:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">rtol</span></code> default value for <code class="docutils literal notranslate"><span class="pre">pinv</span></code> changes from <code class="docutils literal notranslate"><span class="pre">1e-15</span></code> to a
dtype-dependent default value of <code class="docutils literal notranslate"><span class="pre">None</span></code>, interpreted as <code class="docutils literal notranslate"><span class="pre">max(M,</span> <span class="pre">N)</span> <span class="pre">*</span>
<span class="pre">finfo(result_dtype).eps</span></code>,</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">tol</span></code> keyword to <code class="docutils literal notranslate"><span class="pre">matrix_rank</span></code> changes to <code class="docutils literal notranslate"><span class="pre">rtol</span></code> with a different
interpretation. In addition, <code class="docutils literal notranslate"><span class="pre">matrix_rank</span></code> will no longer support 1-D array
input,</p></li>
</ul>
<p>Raising a <code class="docutils literal notranslate"><span class="pre">FutureWarning</span></code> for these tolerance changes doesn’t seem reasonable;
they’d be spurious warnings for the vast majority of users, and it would force
users to hardcode a tolerance value to avoid the warning. Changes in numerical
results are in principle undesirable, so while we expect the impact to be small
it would be good to do this in a major release.</p>
<p><em>We expect the impact of this category of changes to be medium. It is the only
category of changes that does not result in clear exceptions or warnings, and
hence if it does matter (e.g., downstream tests start failing or users notice
a change in behavior) it may require more work from users to track down the problem.
This should happen infrequently - one month after the PR implementing this change
was merged (see</em> <a class="reference external" href="https://github.com/numpy/numpy/pull/25437">gh-25437</a>),
<em>the impact reported so far is a single test failure in AstroPy.</em></p>
<p><strong>Functions moved to numpy.linalg and supporting stacking/batching</strong> are
the <code class="docutils literal notranslate"><span class="pre">diagonal</span></code> and <code class="docutils literal notranslate"><span class="pre">trace</span></code> functions. They part of the <code class="docutils literal notranslate"><span class="pre">linalg</span></code> submodule
in the standard, rather than the main namespace. Hence they will be introduced
in <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code>. They will operate on the last two rather than first two
axes. This is done for consistency, since this is now other NumPy functions
work, and to support “stacking” (or “batching” in more commonly used
terminology in other libraries). Hence the <code class="docutils literal notranslate"><span class="pre">linalg</span></code> and main namespace
functions of the same names will differ. This is technically not breaking, but
potentially confusing because of the different behavior for functions with the
same name. We may deprecate <code class="docutils literal notranslate"><span class="pre">np.trace</span></code> and <code class="docutils literal notranslate"><span class="pre">np.diagonal</span></code> to resolve it, but
preferably not immediately to avoid users having to write <code class="docutils literal notranslate"><span class="pre">if-2.0-else</span></code>
conditional code.</p>
<p><em>We expect the impact of this category of changes to be small.</em></p>
<p><strong>The semantics of the copy keyword in asarray and array</strong> for
<code class="docutils literal notranslate"><span class="pre">copy=False</span></code> will change from “copy if needed” to “never copy”. there are now
three types of behavior rather than two - <code class="docutils literal notranslate"><span class="pre">copy=None</span></code> means “copy if needed”.</p>
<p><em>We expect the impact of this category of changes to be medium. In case users get
an exception because they use</em> <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> <em>explicitly in their copy but a
copy was previously made anyway, they have to inspect their code and determine
whether the intent of the code was the old or the new semantics (both seem
roughly equally likely), and adapt the code as appropriate. We expect most cases
to be</em> <code class="docutils literal notranslate"><span class="pre">np.array(...,</span> <span class="pre">copy=False)</span></code>, <em>because until a few years ago that had
lower overhead than</em> <code class="docutils literal notranslate"><span class="pre">np.asarray(...)</span></code>. <em>This was solved though, and</em>
<code class="docutils literal notranslate"><span class="pre">np.asarray(...)</span></code> <em>is idiomatic NumPy usage.</em></p>
<p><strong>Changes to numpy.fft</strong>: all functions in the <code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code> submodule need to
preserve precision for 32-bit input dtypes rather than upcast to
<code class="docutils literal notranslate"><span class="pre">float64</span></code>/<code class="docutils literal notranslate"><span class="pre">complex128</span></code>. This is a desirable change, consistent with the design
of NumPy as a whole - but it’s possible that the lower precision or the dtype of
the returned arrays from calls to functions in this module may affect users.
This change was made by via a new gufunc-based implementation and vendoring of the
C++ version of PocketFFT in (<a class="reference external" href="https://github.com/numpy/numpy/pull/25711">gh-25711</a>).</p>
<p>A smaller backwards-incompatible change to <code class="docutils literal notranslate"><span class="pre">numpy.fft</span></code> is to make the
behavior of the <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">axes</span></code> arguments in n-D transforms easier to
understand by disallowing <code class="docutils literal notranslate"><span class="pre">None</span></code> values in <code class="docutils literal notranslate"><span class="pre">s</span></code> and requiring that if <code class="docutils literal notranslate"><span class="pre">s</span></code>
is used, <code class="docutils literal notranslate"><span class="pre">axes</span></code> must be specified as well (see
<a class="reference external" href="https://github.com/numpy/numpy/pull/25495">gh-25495</a>).</p>
<p><em>We expect the impact of this category of changes to be small.</em></p>
<section id="adapting-to-the-changes-tooling-support">
<h3>Adapting to the changes &amp; tooling support<a class="headerlink" href="#adapting-to-the-changes-tooling-support" title="Link to this heading">#</a></h3>
<p>Some parts of the array API have already been implemented as part of the general
Python API cleanup for NumPy 2.0 (see NEP 52), such as:</p>
<ul class="simple">
<li><p>establishing one and way for naming <code class="docutils literal notranslate"><span class="pre">inf</span></code> and <code class="docutils literal notranslate"><span class="pre">nan</span></code> that is array API
compatible.</p></li>
<li><p>removing cryptic dtype names and establishing (array API compatible)
canonical names for each dtype.</p></li>
</ul>
<p>All instructions for migrating to a NEP 52 compatible codebase are available in
the <a class="reference external" href="https://numpy.org/devdocs/numpy_2_0_migration_guide.html">NumPy 2.0 Migration Guide</a> .</p>
<p>Additionally, a new <code class="docutils literal notranslate"><span class="pre">ruff</span></code> rule was implemented for an automatic migration of
Python API changes. It’s worth pointing out that the new rule NP201 is only to
adhere to the NEP 52 changes, and does not cover using new functions that are
part of the array API standard nor APIs with some types of backwards
incompatible changes discussed above.</p>
<p>For an automated migration to an array API compatible codebase, a new rule is
being implemented (see issue <a class="reference external" href="https://github.com/astral-sh/ruff/issues/8615">ruff#8615</a>
and PR <a class="reference external" href="https://github.com/astral-sh/ruff/pull/8910">ruff#8910</a>).</p>
<p>With both rules in place a downstream user should be able to update their
project, to the extent that is possible with automation, to a library
agnostic codebase that can benefit from different array libraries and devices.</p>
<p>Backwards incompatible changes that cannot be handled automatically (e.g., a
change in <code class="docutils literal notranslate"><span class="pre">rtol</span></code> defaults for a linear algebra function) will be handled the
in same way as any other backwards incompatible change in NumPy 2.0 -
through documentation, release notes, API migrations and deprecations over
several releases.</p>
</section>
</section>
<section id="detailed-description">
<h2>Detailed description<a class="headerlink" href="#detailed-description" title="Link to this heading">#</a></h2>
<p>In this section we’ll focus on specific API additions and functionality that we
would not consider introducing into NumPy if the standard did not exist and
we didn’t have to think/worry about its main goal: writing code that is
portable across multiple array libraries and their supported features like GPUs
and other hardware accelerators or JIT compilers.</p>
<section id="device-support">
<h3><code class="docutils literal notranslate"><span class="pre">device</span></code> support<a class="headerlink" href="#device-support" title="Link to this heading">#</a></h3>
<p>Device support is perhaps the most obvious example. NumPy is and will remain a
CPU-only library, so why bother introducing a <code class="docutils literal notranslate"><span class="pre">ndarray.device</span></code> attribute or
<code class="docutils literal notranslate"><span class="pre">device=</span></code> keywords in several functions? This one feature is purely meant to
make it easier to write code that is portable across libraries. The <code class="docutils literal notranslate"><span class="pre">.device</span></code>
attribute will return an object representing CPU, and that object will be
accepted as an input to <code class="docutils literal notranslate"><span class="pre">device=</span></code> keywords. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Should work when `xp` is `np` and `x1` a numpy array</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">xp</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">x1</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<p>This will work as expected for NumPy, creating a 1-D numpy array from the input
list. It will also work for CuPy &amp; co, where it may create a new array on a GPU
or other supported device.</p>
</section>
<section id="isdtype">
<h3><code class="docutils literal notranslate"><span class="pre">isdtype</span></code><a class="headerlink" href="#isdtype" title="Link to this heading">#</a></h3>
<p>The array API standard introduced a new function <code class="docutils literal notranslate"><span class="pre">isdtype</span></code> for introspection
of dtypes, because there was no suitable alternative in NumPy. The closest one
is <code class="docutils literal notranslate"><span class="pre">np.issubdtype</span></code>, however that assumes a complex class hierarchy which
other array libraries don’t have, isn’t the most ergonomic API, and required a
larger API surface (<code class="docutils literal notranslate"><span class="pre">np.floating</span></code> and friends). <code class="docutils literal notranslate"><span class="pre">isdtype</span></code> will be the new
and canonical way to introspect dtypes. All it requires from a dtype is that
<code class="docutils literal notranslate"><span class="pre">__eq__</span></code> is implemented and has the expected behavior when compared with other
dtypes from the same library.</p>
<p>Note that as part of the effort on NEP 52, some dtype aliases were removed and
canonical Python and C names documented. See also <a class="reference external" href="https://github.com/numpy/numpy/issues/17325">gh-17325</a> covering issues with NumPy’s
lack of a good API for this.</p>
</section>
<section id="copy-keyword-semantics">
<h3><code class="docutils literal notranslate"><span class="pre">copy</span></code> keyword semantics<a class="headerlink" href="#copy-keyword-semantics" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">copy</span></code> keyword in <code class="docutils literal notranslate"><span class="pre">asarray</span></code> and <code class="docutils literal notranslate"><span class="pre">array</span></code> will now support
<code class="docutils literal notranslate"><span class="pre">True</span></code>/<code class="docutils literal notranslate"><span class="pre">False</span></code>/<code class="docutils literal notranslate"><span class="pre">None</span></code> with new meanings:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code> - Always make a copy.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code> - Never make a copy. If a copy is required, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - A copy will only be made if it is necessary (previously <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">copy</span></code> keyword in <code class="docutils literal notranslate"><span class="pre">astype</span></code> will stick to its current meaning, because
“never copy” when asking for a cast to a different dtype doesn’t quite make
sense.</p>
<p>There is still one hiccup for the change in semantics: if for user code
<code class="docutils literal notranslate"><span class="pre">np.array(obj,</span> <span class="pre">copy=False)</span></code>, NumPy may end up calling <code class="docutils literal notranslate"><span class="pre">obj.__array__</span></code> and
in that case turning the result into a NumPy array is the responsibility of the
implementer of <code class="docutils literal notranslate"><span class="pre">obj.__array__</span></code>. Therefore, we need to add a <code class="docutils literal notranslate"><span class="pre">copy=None</span></code>
keyword to <code class="docutils literal notranslate"><span class="pre">__array__</span></code> as well, and pass the copy keyword value along - taking
care to not break backwards compatibility when the implementer of <code class="docutils literal notranslate"><span class="pre">__array__</span></code>
does not yet have the new keyword (a <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code> will be emitted in
that case, to allow for a gradual transition).</p>
</section>
<section id="new-function-name-aliases">
<h3>New function name aliases<a class="headerlink" href="#new-function-name-aliases" title="Link to this heading">#</a></h3>
<p>In the Python API cleanup for NumPy 2.0 (see <a class="reference internal" href="nep-0052-python-api-cleanup.html#nep52"><span class="std std-ref">NEP 52 — Python API cleanup for NumPy 2.0</span></a>) we spent a lot of
effort removing aliases. So introducing new aliases has to have a good
rationale. In this case, it is needed in order to match other libraries.
The main set of aliases added is for trigonometric functions, where
the array API standard chose to follow C99 and other libraries in using
<code class="docutils literal notranslate"><span class="pre">acos</span></code>, <code class="docutils literal notranslate"><span class="pre">asin</span></code> etc. rather than <code class="docutils literal notranslate"><span class="pre">arccos</span></code>, <code class="docutils literal notranslate"><span class="pre">arcsin</span></code>, etc. NumPy usually
also follows C99; it is not entirely clear why this naming choice was made many
years ago.</p>
<p>In total 13 aliases are added to the main namespace and 2 aliases to
<code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code>:</p>
<ul class="simple">
<li><p>trigonometry functions: <code class="docutils literal notranslate"><span class="pre">acos</span></code>, <code class="docutils literal notranslate"><span class="pre">acosh</span></code>, <code class="docutils literal notranslate"><span class="pre">asin</span></code>, <code class="docutils literal notranslate"><span class="pre">asinh</span></code>, <code class="docutils literal notranslate"><span class="pre">atan</span></code>,
<code class="docutils literal notranslate"><span class="pre">atanh</span></code>, <code class="docutils literal notranslate"><span class="pre">atan2</span></code></p></li>
<li><p>bit-wise functions: <code class="docutils literal notranslate"><span class="pre">bitwise_left_shift</span></code>, <code class="docutils literal notranslate"><span class="pre">bitwise_invert</span></code>,
<code class="docutils literal notranslate"><span class="pre">bitwise_right_shift</span></code></p></li>
<li><p>other functions: <code class="docutils literal notranslate"><span class="pre">concat</span></code>, <code class="docutils literal notranslate"><span class="pre">permute_dims</span></code>, <code class="docutils literal notranslate"><span class="pre">pow</span></code></p></li>
<li><p>in <code class="docutils literal notranslate"><span class="pre">numpy.linalg</span></code>: <code class="docutils literal notranslate"><span class="pre">tensordot</span></code>, <code class="docutils literal notranslate"><span class="pre">matmul</span></code></p></li>
</ul>
<p>In the future NumPy can choose to hide the original names from its <code class="docutils literal notranslate"><span class="pre">__dir__</span></code>
to nudge users to the preferred spelling for each function.</p>
</section>
<section id="new-keywords-with-overlapping-semantics">
<h3>New keywords with overlapping semantics<a class="headerlink" href="#new-keywords-with-overlapping-semantics" title="Link to this heading">#</a></h3>
<p>Similarly to function name aliases, there are a couple of new keywords which
have overlap with existing ones:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">correction</span></code> keyword for <code class="docutils literal notranslate"><span class="pre">std</span></code> and <code class="docutils literal notranslate"><span class="pre">var</span></code> (overlaps with <code class="docutils literal notranslate"><span class="pre">ddof</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stable</span></code> keyword for <code class="docutils literal notranslate"><span class="pre">sort</span></code> and <code class="docutils literal notranslate"><span class="pre">argsort</span></code> (overlaps with <code class="docutils literal notranslate"><span class="pre">kind</span></code>)</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">correction</span></code> name is for clarity (“delta degrees of freedom” is not easy
to understand). <code class="docutils literal notranslate"><span class="pre">stable</span></code> is complementary to <code class="docutils literal notranslate"><span class="pre">kind</span></code>, which already has
<code class="docutils literal notranslate"><span class="pre">'stable'</span></code> as an option (a separate keyword may be more discoverable though
and hence nice to have anyway), allowing a library to reserve the right to
change/improve the stable and unstable sorting algorithms.</p>
</section>
<section id="new-unique-functions">
<h3>New <code class="docutils literal notranslate"><span class="pre">unique_*</span></code> functions<a class="headerlink" href="#new-unique-functions" title="Link to this heading">#</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">unique</span></code> function, with <code class="docutils literal notranslate"><span class="pre">return_index</span></code>, <code class="docutils literal notranslate"><span class="pre">return_inverse</span></code>, and
<code class="docutils literal notranslate"><span class="pre">return_counts</span></code> arguments that influence the cardinality of the returned
tuple, is replaced in the array API by four respective functions:
<code class="docutils literal notranslate"><span class="pre">unique_all</span></code>, <code class="docutils literal notranslate"><span class="pre">unique_counts</span></code>, <code class="docutils literal notranslate"><span class="pre">unique_inverse</span></code>, and <code class="docutils literal notranslate"><span class="pre">unique_values</span></code>.
These new functions avoid polymorphism, which tends to be a problem for JIT
compilers and static typing. Use of these functions therefore helps tools like
Numba as well as users of static type checkers like Mypy.</p>
</section>
<section id="np-bool-addition">
<h3><code class="docutils literal notranslate"><span class="pre">np.bool</span></code> addition<a class="headerlink" href="#np-bool-addition" title="Link to this heading">#</a></h3>
<p>One of the aliases that used to live in NumPy but was removed is <code class="docutils literal notranslate"><span class="pre">np.bool</span></code>.
To comply with the array API it was reintroduced with a different meaning, as
now it points to NumPy’s bool instead of a Python builtin. This change is a
good idea and we were planning to make it anyway, because <code class="docutils literal notranslate"><span class="pre">bool</span></code> is a nicer
name than <code class="docutils literal notranslate"><span class="pre">bool_</span></code>. However, we may not have scheduled that reintroduction of
the name for 2.0 if it had not been part of the array API standard.</p>
</section>
</section>
<section id="parts-of-the-standard-that-are-not-adopted">
<h2>Parts of the standard that are not adopted<a class="headerlink" href="#parts-of-the-standard-that-are-not-adopted" title="Link to this heading">#</a></h2>
<p>There are a couple of things that the standard prescribes which we propose <em>not</em>
to follow (at least at this time). These are:</p>
<ol class="arabic">
<li><p>The requirement for <code class="docutils literal notranslate"><span class="pre">sum</span></code> and <code class="docutils literal notranslate"><span class="pre">prod</span></code> to always upcast lower-precision
floating-point dtypes to <code class="docutils literal notranslate"><span class="pre">float64</span></code> when <code class="docutils literal notranslate"><span class="pre">dtype=None</span></code>.</p>
<p><em>Rationale: this is potentially disruptive (e.g.,</em> <code class="docutils literal notranslate"><span class="pre">float32_arr</span> <span class="pre">-</span> <span class="pre">float32_arr.mean()</span></code>
<em>would yield a float64 array, and double memory use). While this upcasting
is already done for inputs with lower-precision integer dtypes and seems
useful there to prevent overflows, it seems less reasonable to require this
for floating-point dtypes.</em></p>
<p><a class="reference external" href="https://github.com/data-apis/array-api/issues/731">array-api#731</a> was
opened to reconsider this design choice in the standard, and that was accepted
for the next standard version.</p>
</li>
<li><p>Making function signatures positional-only and keyword-only in many places.</p>
<p><em>Rationale: the 2022.12 version of the standard said “must”, but this has
already been softened to “should” in the about-to-be-released 2023.12
version, to recognize that it’s okay to not do this - it’s still possible for
users of the array library to write their code using the recommended style
after all. For NumPy these changes would be useful, and it seems likely that
we may introduce many or all of them over time (and in fact ufuncs are
already compliant), however there is no need to rush this change - doing so
for 2.0 would be unnecessarily disruptive.</em></p>
</li>
<li><p>The requirement “An in-place operation must have the same behavior
(including special cases) as its respective binary (i.e., two operand,
non-assignment) operation” (excluding the effect on views).</p>
<p><em>Rationale: the requirement is very reasonable and probably expected
behavior for most NumPy users. However, deprecating unsafe casts for
in-place operators is a change for which the impact is hard to predict.
Hence this needs to be investigated first, and then if the impact is low
enough it may be possible to deprecate the current behavior according to
NumPy’s normal backwards compatibility guidelines.</em></p>
<p>This topic is tracked in
<a class="reference external" href="https://github.com/numpy/numpy/issues/25621">gh-25621</a>.</p>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We note that one NumPy-specific behavior that remains is returning array
scalars rather than 0-D arrays in most cases where the standard, and other
array libraries, return 0-D arrays (e.g., indexing and reductions). Array
scalars basically duck type 0-D arrays, which is allowed by the standard (it
doesn’t mandate that there is only one array type, nor contains
<code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks or other semantics that won’t work with array
scalars). There have been multiple discussions over the past year about the
feasibility of removing array scalars from NumPy, or at least no longer
returning them by default. However, this would be a large effort with some
uncertainty about technical risks and impact of the change, and no one has
taken it on. Given that array scalars implement a largely array-compatible
interface, this doesn’t seem like the highest-prio item regarding array API
standard compatibility (or in general).</p>
</div>
</section>
<section id="related-work">
<h2>Related work<a class="headerlink" href="#related-work" title="Link to this heading">#</a></h2>
<p>The array API standard (<a class="reference external" href="https://data-apis.org/array-api/2022.12/">html docs</a>,
<a class="reference external" href="https://github.com/data-apis/array-api/">repository</a>) is the first related
work; a lot of design discussion in its issue tracker may be relevant in case
reasons for particular decisions need to be found.</p>
<p>Downstream adoption from array-consuming libraries is actively happening at the moment,
see for example:</p>
<ul class="simple">
<li><p>scikit-learn <a class="reference external" href="https://scikit-learn.org/dev/modules/array_api.html">docs on array API support</a> and
<a class="reference external" href="https://github.com/scikit-learn/scikit-learn/pulls?q=is%3Aopen+is%3Apr+label%3A%22Array+API%22">PRs</a> and
<a class="reference external" href="https://github.com/scikit-learn/scikit-learn/issues?q=is%3Aopen+is%3Aissue+label%3A%22Array+API%22">issues</a>
labeled with <em>Array API</em>.</p></li>
<li><p>SciPy <a class="reference external" href="http://scipy.github.io/devdocs/dev/api-dev/array_api.html">docs on array API support</a>
and <a class="reference external" href="https://github.com/scipy/scipy/pulls?q=is%3Aopen+is%3Apr+label%3A%22array+types%22">PRs</a>
and <a class="reference external" href="https://github.com/scipy/scipy/issues?q=is%3Aopen+is%3Aissue+label%3A%22array+types%22">issues</a> labeled with <em>array types</em>.</p></li>
<li><p>Einops <a class="reference external" href="https://einops.rocks/#supported-frameworks">docs on supported frameworks</a>
and <a class="reference external" href="https://github.com/arogozhnikov/einops/pull/261">PR to implement array API standard support</a>.</p></li>
</ul>
<p>Other array libraries either already have support or are implementing support
for the array API standard (in sync with the changes for NumPy 2.0, since they
usually try to be as compatible to NumPy as possible). For example:</p>
<ul class="simple">
<li><p>CuPy’s <a class="reference external" href="https://docs.cupy.dev/en/stable/reference/array_api.html">docs on array API support</a>
and <a class="reference external" href="https://github.com/cupy/cupy/pulls?q=is%3Aopen+is%3Apr+label%3Aarray-api">PRs labelled with array-api</a>.</p></li>
<li><p>JAX: enhancement proposal <a class="reference external" href="https://jax.readthedocs.io/en/latest/jep/18137-numpy-scipy-scope.html#axis-2-array-api-alignment">Scope of JAX NumPy &amp; SciPy Wrappers</a>
and <a class="reference external" href="https://github.com/google/jax/issues/18353">tracking issue</a>.</p></li>
</ul>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">#</a></h2>
<p>The tracking issue for Array API standard support
(<a class="reference external" href="https://github.com/numpy/numpy/issues/25076">gh-25076</a>)
records progress of implementing full support and links to related discussions.
It lists all relevant PRs (merged and pending) that verify or provide array API
support.</p>
<p>As NEP 52 blends to some degree with this NEP, we can find some relevant implementations
and discussion also on its tracking issue (<a class="reference external" href="https://github.com/numpy/numpy/issues/23999">gh-23999</a>).</p>
<p>The PR that was merged as one of the first contained a new CI job that adds the
<a class="reference external" href="https://github.com/data-apis/array-api-tests">array-api-tests</a> test suite.
This way we had a better control over which batch of functions/aliases were being
added each time, and could be sure that the implementations conformed to the array
API standard (see <a class="reference external" href="https://github.com/numpy/numpy/pull/25167">gh-25167</a>).</p>
<p>Then, we continued to merge one batch at the time, adding a specific API
section. Below we list some of the more substantial ones, including some that
we discussed in the previous sections of this NEP:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25167">gh-25167: MAINT: Add array-api-tests CI stage, add ndarray.__array_namespace__</a>.</p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25088">gh-25088: API: Add Array API setops [Array API]</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25155">gh-25155: API: Add matrix_norm, vector_norm, vecdot and matrix_transpose [Array API]</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25080">gh-25080: API: Add and redefine numpy.bool [Array API]</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25054">gh-25054: API: Introduce np.isdtype function [Array API]</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy/pull/25168">gh-25168: API: Introduce copy argument for np.asarray [Array API]</a></p></li>
</ul>
</section>
<section id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Link to this heading">#</a></h2>
<p>The alternatives to implementing support for the array API standard in NumPy’s
main namespace include:</p>
<ul class="simple">
<li><p>one or more of the superseded NEPs, or</p></li>
<li><p>making <code class="docutils literal notranslate"><span class="pre">ndarray.__array_namespace__()</span></code> return a hidden namespace (or even
another new public namespace) with compatible functions,</p></li>
<li><p>not implementing support for the array API standard at all.</p></li>
</ul>
<p>The superseded NEPs all have some drawbacks compared to the array API standard,
and by now a lot of work has gone into the standard - as well as adoption by
other key libraries. So those alternatives are not appealing. Given the amount
of interest in this topic, doing nothing also is not appealing. The “hidden
namespace” option would be a smaller change to this proposal. We prefer not to
do that since it leads to duplicate implementations staying around, a more
complex implementation (e.g., potential issues with static typing), and still
having two flavors of essentially the same API.</p>
<p>An alternative to removing <code class="docutils literal notranslate"><span class="pre">numpy.array_api</span></code> from NumPy is to keep it in its
current place, since it is still useful - it is the best way to test if
downstream code is actually portable between array libraries. This is a very
reasonable alternative, however there is a slight preference for taking that
module and turning it into a standalone package.</p>
</section>
<section id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Link to this heading">#</a></h2>
</section>
<section id="references-and-footnotes">
<h2>References and footnotes<a class="headerlink" href="#references-and-footnotes" title="Link to this heading">#</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://labs.quansight.org/blog/array-api-support-scikit-learn">https://labs.quansight.org/blog/array-api-support-scikit-learn</a></p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://labs.quansight.org/blog/scipy-array-api">https://labs.quansight.org/blog/scipy-array-api</a></p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple">
<li><p>Meurer et al., “Python Array API Standard: Toward Array Interoperability in the Scientific Python Ecosystem.” (2023), <a class="reference external" href="https://conference.scipy.org/proceedings/scipy2023/pdfs/aaron_meurer.pdf">https://conference.scipy.org/proceedings/scipy2023/pdfs/aaron_meurer.pdf</a></p></li>
</ol>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://numpy.org/user-survey-2020/">https://numpy.org/user-survey-2020/</a>, 2020 NumPy User Survey results</p>
</aside>
</aside>
</section>
<section id="copyright">
<h2>Copyright<a class="headerlink" href="#copyright" title="Link to this heading">#</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract">Abstract</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#motivation-and-scope">Motivation and scope</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-and-impact">Usage and impact</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#backward-compatibility">Backward compatibility</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adapting-to-the-changes-tooling-support">Adapting to the changes &amp; tooling support</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#detailed-description">Detailed description</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-support"><code class="docutils literal notranslate"><span class="pre">device</span></code> support</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#isdtype"><code class="docutils literal notranslate"><span class="pre">isdtype</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#copy-keyword-semantics"><code class="docutils literal notranslate"><span class="pre">copy</span></code> keyword semantics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#new-function-name-aliases">New function name aliases</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#new-keywords-with-overlapping-semantics">New keywords with overlapping semantics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#new-unique-functions">New <code class="docutils literal notranslate"><span class="pre">unique_*</span></code> functions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#np-bool-addition"><code class="docutils literal notranslate"><span class="pre">np.bool</span></code> addition</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parts-of-the-standard-that-are-not-adopted">Parts of the standard that are not adopted</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#related-work">Related work</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implementation">Implementation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#alternatives">Alternatives</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discussion">Discussion</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references-and-footnotes">References and footnotes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#copyright">Copyright</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2017-2025, NumPy Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>